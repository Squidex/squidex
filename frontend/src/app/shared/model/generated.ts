//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { hasAnyLink, DateTime, StringHelper, Types, ApiUrlConfig, ErrorDto } from '@app/framework';
import { FieldPropertiesVisitor, META_FIELDS, tableField, tableFields } from './schemas';

export class ServerErrorDto implements IServerErrorDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Error message. */
    readonly message!: string;
    /** The error code. */
    readonly errorCode?: string | undefined;
    /** The optional trace id. */
    readonly traceId?: string | undefined;
    /** Link to the error details. */
    readonly type?: string | undefined;
    /** Detailed error messages. */
    readonly details?: string[] | undefined;
    /** Status code of the http response. */
    readonly statusCode!: number;

    toError(): ErrorDto {
        return new ErrorDto(
            this.statusCode,
            this.message,
            this.errorCode,
            this.details);
    }

    constructor(data?: IServerErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).message = _data["message"];
        (<any>this).errorCode = _data["errorCode"];
        (<any>this).traceId = _data["traceId"];
        (<any>this).type = _data["type"];
        if (Array.isArray(_data["details"])) {
            (<any>this).details = [] as any;
            for (let item of _data["details"])
                (<any>this).details!.push(item);
        }
        (<any>this).statusCode = _data["statusCode"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ServerErrorDto {
        const result = new ServerErrorDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["message"] = this.message;
        data["errorCode"] = this.errorCode;
        data["traceId"] = this.traceId;
        data["type"] = this.type;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        data["statusCode"] = this.statusCode;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IServerErrorDto {
    /** Error message. */
    readonly message: string;
    /** The error code. */
    readonly errorCode?: string | undefined;
    /** The optional trace id. */
    readonly traceId?: string | undefined;
    /** Link to the error details. */
    readonly type?: string | undefined;
    /** Detailed error messages. */
    readonly details?: string[] | undefined;
    /** Status code of the http response. */
    readonly statusCode: number;
}

export class UserPropertyDto implements IUserPropertyDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    readonly name!: string;
    readonly value!: string;

    constructor(data?: IUserPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).value = _data["value"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UserPropertyDto {
        const result = new UserPropertyDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["value"] = this.value;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUserPropertyDto {
    readonly name: string;
    readonly value: string;
}

export class UpdateSettingDto implements IUpdateSettingDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The value for the setting. */
    readonly value!: any;

    constructor(data?: IUpdateSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).value = _data["value"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateSettingDto {
        const result = new UpdateSettingDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["value"] = this.value;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateSettingDto {
    /** The value for the setting. */
    readonly value: any;
}

export abstract class ResourceDto implements IResourceDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The links. */
    readonly _links!: { [key: string]: ResourceLinkDto; };

    constructor(data?: IResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (_data["_links"]) {
            (<any>this)._links = {} as any;
            for (let key in _data["_links"]) {
                if (_data["_links"].hasOwnProperty(key))
                    (<any>(<any>this)._links)![key] = _data["_links"][key] ? ResourceLinkDto.fromJSON(_data["_links"][key]) : new ResourceLinkDto();
            }
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ResourceDto {
        throw new Error("The abstract class 'ResourceDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this._links) {
            data["_links"] = {};
            for (let key in this._links) {
                if (this._links.hasOwnProperty(key))
                    (<any>data["_links"])[key] = this._links[key] ? this._links[key].toJSON() : <any>undefined;
            }
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IResourceDto {
    /** The links. */
    readonly _links: { [key: string]: ResourceLinkDto; };
}

export class UsersDto extends ResourceDto implements IUsersDto {
    /** The total number of users. */
    readonly total!: number;
    /** The users. */
    readonly items!: UserDto[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    constructor(data?: IUsersDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).total = _data["total"];
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(UserDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UsersDto {
        const result = new UsersDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IUsersDto extends IResourceDto {
    /** The total number of users. */
    readonly total: number;
    /** The users. */
    readonly items: UserDto[];
}

export class UserDto extends ResourceDto implements IUserDto {
    /** The ID of the user. */
    readonly id!: string;
    /** The email of the user. Unique value. */
    readonly email!: string;
    /** The display name (usually first name and last name) of the user. */
    readonly displayName!: string;
    /** Determines if the user is locked. */
    readonly isLocked!: boolean;
    /** Additional permissions for the user. */
    readonly permissions!: string[];

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canLock() {
        return this.compute('canLock', () => hasAnyLink(this._links, 'lock'));
    }

    get canUnlock() {
        return this.compute('canUnlock', () => hasAnyLink(this._links, 'unlock'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IUserDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).email = _data["email"];
        (<any>this).displayName = _data["displayName"];
        (<any>this).isLocked = _data["isLocked"];
        if (Array.isArray(_data["permissions"])) {
            (<any>this).permissions = [] as any;
            for (let item of _data["permissions"])
                (<any>this).permissions!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UserDto {
        const result = new UserDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        data["isLocked"] = this.isLocked;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IUserDto extends IResourceDto {
    /** The ID of the user. */
    readonly id: string;
    /** The email of the user. Unique value. */
    readonly email: string;
    /** The display name (usually first name and last name) of the user. */
    readonly displayName: string;
    /** Determines if the user is locked. */
    readonly isLocked: boolean;
    /** Additional permissions for the user. */
    readonly permissions: string[];
}

export class ResourceLinkDto implements IResourceLinkDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The link url. */
    readonly href!: string;
    /** The link method. */
    readonly method!: string;
    /** Additional data about the link. */
    readonly metadata?: string | undefined;

    constructor(data?: IResourceLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).href = _data["href"];
        (<any>this).method = _data["method"];
        (<any>this).metadata = _data["metadata"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ResourceLinkDto {
        const result = new ResourceLinkDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["href"] = this.href;
        data["method"] = this.method;
        data["metadata"] = this.metadata;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IResourceLinkDto {
    /** The link url. */
    readonly href: string;
    /** The link method. */
    readonly method: string;
    /** Additional data about the link. */
    readonly metadata?: string | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The email of the user. Unique value. */
    readonly email!: string;
    /** The display name (usually first name and last name) of the user. */
    readonly displayName!: string;
    /** The password of the user. */
    readonly password!: string;
    /** Additional permissions for the user. */
    readonly permissions!: string[];

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).email = _data["email"];
        (<any>this).displayName = _data["displayName"];
        (<any>this).password = _data["password"];
        if (Array.isArray(_data["permissions"])) {
            (<any>this).permissions = [] as any;
            for (let item of _data["permissions"])
                (<any>this).permissions!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateUserDto {
        const result = new CreateUserDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        data["password"] = this.password;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICreateUserDto {
    /** The email of the user. Unique value. */
    readonly email: string;
    /** The display name (usually first name and last name) of the user. */
    readonly displayName: string;
    /** The password of the user. */
    readonly password: string;
    /** Additional permissions for the user. */
    readonly permissions: string[];
}

export class UpdateUserDto implements IUpdateUserDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The email of the user. Unique value. */
    readonly email!: string;
    /** The display name (usually first name and last name) of the user. */
    readonly displayName!: string;
    /** The password of the user. */
    readonly password?: string | undefined;
    /** Additional permissions for the user. */
    readonly permissions!: string[];

    constructor(data?: IUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).email = _data["email"];
        (<any>this).displayName = _data["displayName"];
        (<any>this).password = _data["password"];
        if (Array.isArray(_data["permissions"])) {
            (<any>this).permissions = [] as any;
            for (let item of _data["permissions"])
                (<any>this).permissions!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateUserDto {
        const result = new UpdateUserDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        data["password"] = this.password;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateUserDto {
    /** The email of the user. Unique value. */
    readonly email: string;
    /** The display name (usually first name and last name) of the user. */
    readonly displayName: string;
    /** The password of the user. */
    readonly password?: string | undefined;
    /** Additional permissions for the user. */
    readonly permissions: string[];
}

export class ResourcesDto extends ResourceDto implements IResourcesDto {

    constructor(data?: IResourcesDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ResourcesDto {
        const result = new ResourcesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IResourcesDto extends IResourceDto {
}

export class UpdateProfileDto implements IUpdateProfileDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The answers from a questionaire. */
    readonly answers?: { [key: string]: string; } | undefined;

    constructor(data?: IUpdateProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (_data["answers"]) {
            (<any>this).answers = {} as any;
            for (let key in _data["answers"]) {
                if (_data["answers"].hasOwnProperty(key))
                    (<any>(<any>this).answers)![key] = _data["answers"][key];
            }
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateProfileDto {
        const result = new UpdateProfileDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this.answers) {
            data["answers"] = {};
            for (let key in this.answers) {
                if (this.answers.hasOwnProperty(key))
                    (<any>data["answers"])[key] = (<any>this.answers)[key];
            }
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateProfileDto {
    /** The answers from a questionaire. */
    readonly answers?: { [key: string]: string; } | undefined;
}

export class TranslationDto implements ITranslationDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The result of the translation. */
    readonly status!: TranslationStatus;
    /** The result of the translation. */
    readonly result!: TranslationStatus;
    /** The translated text. */
    readonly text?: string | undefined;

    constructor(data?: ITranslationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).status = _data["status"];
        (<any>this).result = _data["result"];
        (<any>this).text = _data["text"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TranslationDto {
        const result = new TranslationDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["status"] = this.status;
        data["result"] = this.result;
        data["text"] = this.text;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ITranslationDto {
    /** The result of the translation. */
    readonly status: TranslationStatus;
    /** The result of the translation. */
    readonly result: TranslationStatus;
    /** The translated text. */
    readonly text?: string | undefined;
}

export type TranslationStatus = "Translated" | "LanguageNotSupported" | "NotTranslated" | "NotConfigured" | "Unauthorized" | "Failed";

export const TranslationStatusValues: ReadonlyArray<TranslationStatus> = [
	"Translated",
	"LanguageNotSupported",
	"NotTranslated",
	"NotConfigured",
	"Unauthorized",
	"Failed"
];

export class TranslateDto implements ITranslateDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The text to translate. */
    readonly text!: string;
    /** The target language. */
    readonly targetLanguage!: string;
    /** The optional source language. */
    readonly sourceLanguage?: string | undefined;

    constructor(data?: ITranslateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).text = _data["text"];
        (<any>this).targetLanguage = _data["targetLanguage"];
        (<any>this).sourceLanguage = _data["sourceLanguage"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TranslateDto {
        const result = new TranslateDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["text"] = this.text;
        data["targetLanguage"] = this.targetLanguage;
        data["sourceLanguage"] = this.sourceLanguage;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ITranslateDto {
    /** The text to translate. */
    readonly text: string;
    /** The target language. */
    readonly targetLanguage: string;
    /** The optional source language. */
    readonly sourceLanguage?: string | undefined;
}

export class TemplatesDto extends ResourceDto implements ITemplatesDto {
    /** The event consumers. */
    readonly items!: TemplateDto[];

    constructor(data?: ITemplatesDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(TemplateDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TemplatesDto {
        const result = new TemplatesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ITemplatesDto extends IResourceDto {
    /** The event consumers. */
    readonly items: TemplateDto[];
}

export class TemplateDto extends ResourceDto implements ITemplateDto {
    /** The name of the template. */
    readonly name!: string;
    /** The title of the template. */
    readonly title!: string;
    /** The description of the template. */
    readonly description!: string;
    /** True, if the template is a starter. */
    readonly isStarter!: boolean;

    constructor(data?: ITemplateDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).name = _data["name"];
        (<any>this).title = _data["title"];
        (<any>this).description = _data["description"];
        (<any>this).isStarter = _data["isStarter"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TemplateDto {
        const result = new TemplateDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isStarter"] = this.isStarter;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ITemplateDto extends IResourceDto {
    /** The name of the template. */
    readonly name: string;
    /** The title of the template. */
    readonly title: string;
    /** The description of the template. */
    readonly description: string;
    /** True, if the template is a starter. */
    readonly isStarter: boolean;
}

export class TemplateDetailsDto extends ResourceDto implements ITemplateDetailsDto {
    /** The details of the template. */
    readonly details!: string;

    constructor(data?: ITemplateDetailsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).details = _data["details"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TemplateDetailsDto {
        const result = new TemplateDetailsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["details"] = this.details;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ITemplateDetailsDto extends IResourceDto {
    /** The details of the template. */
    readonly details: string;
}

export class ContributorsDto extends ResourceDto implements IContributorsDto {
    /** The contributors. */
    readonly items!: ContributorDto[];
    /** The maximum number of allowed contributors. */
    readonly maxContributors!: number;
    /** The metadata to provide information about this request. */
    readonly _meta?: ContributorsMetadataDto | undefined;

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    get isInvited() {
        return this.compute('isInvited', () => this._meta?.['isInvited'] === '1');
    }

    constructor(data?: IContributorsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(ContributorDto.fromJSON(item));
        }
        (<any>this).maxContributors = _data["maxContributors"];
        (<any>this)._meta = _data["_meta"] ? ContributorsMetadataDto.fromJSON(_data["_meta"]) : <any>undefined;
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ContributorsDto {
        const result = new ContributorsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["maxContributors"] = this.maxContributors;
        data["_meta"] = this._meta ? this._meta.toJSON() : <any>undefined;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IContributorsDto extends IResourceDto {
    /** The contributors. */
    readonly items: ContributorDto[];
    /** The maximum number of allowed contributors. */
    readonly maxContributors: number;
    /** The metadata to provide information about this request. */
    readonly _meta?: ContributorsMetadataDto | undefined;
}

export class ContributorDto extends ResourceDto implements IContributorDto {
    /** The ID of the user that contributes to the app. */
    readonly contributorId!: string;
    /** The display name. */
    readonly contributorName!: string;
    /** The email address. */
    readonly contributorEmail!: string;
    /** The role of the contributor. */
    readonly role?: string | undefined;

    public get token() {
        return `subject:${this.contributorId}`;
    }

    get canRevoke() {
        return this.compute('canRevoke ', () => hasAnyLink(this._links, 'update'));
    }

    get canUpdate() {
        return this.compute('canUpdate  ', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IContributorDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).contributorId = _data["contributorId"];
        (<any>this).contributorName = _data["contributorName"];
        (<any>this).contributorEmail = _data["contributorEmail"];
        (<any>this).role = _data["role"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ContributorDto {
        const result = new ContributorDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["contributorId"] = this.contributorId;
        data["contributorName"] = this.contributorName;
        data["contributorEmail"] = this.contributorEmail;
        data["role"] = this.role;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IContributorDto extends IResourceDto {
    /** The ID of the user that contributes to the app. */
    readonly contributorId: string;
    /** The display name. */
    readonly contributorName: string;
    /** The email address. */
    readonly contributorEmail: string;
    /** The role of the contributor. */
    readonly role?: string | undefined;
}

export class ContributorsMetadataDto implements IContributorsMetadataDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Indicates whether the user has been invited. */
    readonly isInvited!: string;

    constructor(data?: IContributorsMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).isInvited = _data["isInvited"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ContributorsMetadataDto {
        const result = new ContributorsMetadataDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["isInvited"] = this.isInvited;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IContributorsMetadataDto {
    /** Indicates whether the user has been invited. */
    readonly isInvited: string;
}

export class AssignContributorDto implements IAssignContributorDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The id or email of the user to add to the app. */
    readonly contributorId!: string;
    /** The role of the contributor. */
    readonly role?: string | undefined;
    /** Set to true to invite the user if he does not exist. */
    readonly invite?: boolean;

    constructor(data?: IAssignContributorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).contributorId = _data["contributorId"];
        (<any>this).role = _data["role"];
        (<any>this).invite = _data["invite"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AssignContributorDto {
        const result = new AssignContributorDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["contributorId"] = this.contributorId;
        data["role"] = this.role;
        data["invite"] = this.invite;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAssignContributorDto {
    /** The id or email of the user to add to the app. */
    readonly contributorId: string;
    /** The role of the contributor. */
    readonly role?: string | undefined;
    /** Set to true to invite the user if he does not exist. */
    readonly invite?: boolean;
}

export class TeamDto extends ResourceDto implements ITeamDto {
    /** The user that has created the app. */
    readonly createdBy?: string | undefined;
    /** The user that has updated the app. */
    readonly lastModifiedBy?: string | undefined;
    /** The ID of the team. */
    readonly id!: string;
    /** The name of the team. */
    readonly name!: string;
    /** The version of the team. */
    readonly version!: number;
    /** The timestamp when the team has been created. */
    readonly created!: DateTime;
    /** The timestamp when the team has been modified last. */
    readonly lastModified!: DateTime;
    /** The role name of the user. */
    readonly roleName?: string | undefined;

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canReadAuth() {
        return this.compute('canReadAuth', () => hasAnyLink(this._links, 'auth'));
    }

    get canReadContributors() {
        return this.compute('canReadContributors', () => hasAnyLink(this._links, 'contributors'));
    }

    get canReadPlans() {
        return this.compute('canReadPlans', () => hasAnyLink(this._links, 'plans'));
    }

    get canUpdateGeneral() {
        return this.compute('canUpdateGeneral', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: ITeamDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).createdBy = _data["createdBy"];
        (<any>this).lastModifiedBy = _data["lastModifiedBy"];
        (<any>this).id = _data["id"];
        (<any>this).name = _data["name"];
        (<any>this).version = _data["version"];
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).lastModified = _data["lastModified"] ? DateTime.parseISO(_data["lastModified"].toString()) : <any>undefined;
        (<any>this).roleName = _data["roleName"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TeamDto {
        const result = new TeamDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["id"] = this.id;
        data["name"] = this.name;
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["roleName"] = this.roleName;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ITeamDto extends IResourceDto {
    /** The user that has created the app. */
    readonly createdBy?: string | undefined;
    /** The user that has updated the app. */
    readonly lastModifiedBy?: string | undefined;
    /** The ID of the team. */
    readonly id: string;
    /** The name of the team. */
    readonly name: string;
    /** The version of the team. */
    readonly version: number;
    /** The timestamp when the team has been created. */
    readonly created: DateTime;
    /** The timestamp when the team has been modified last. */
    readonly lastModified: DateTime;
    /** The role name of the user. */
    readonly roleName?: string | undefined;
}

export class CreateTeamDto implements ICreateTeamDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the team. */
    readonly name!: string;

    constructor(data?: ICreateTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateTeamDto {
        const result = new CreateTeamDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICreateTeamDto {
    /** The name of the team. */
    readonly name: string;
}

export class UpdateTeamDto implements IUpdateTeamDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the team. */
    readonly name!: string;

    constructor(data?: IUpdateTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateTeamDto {
        const result = new UpdateTeamDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateTeamDto {
    /** The name of the team. */
    readonly name: string;
}

export class AuthSchemeResponseDto extends ResourceDto implements IAuthSchemeResponseDto {
    /** The auth scheme if configured. */
    readonly scheme?: AuthSchemeDto | undefined;

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IAuthSchemeResponseDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).scheme = _data["scheme"] ? AuthSchemeDto.fromJSON(_data["scheme"]) : <any>undefined;
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AuthSchemeResponseDto {
        const result = new AuthSchemeResponseDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["scheme"] = this.scheme ? this.scheme.toJSON() : <any>undefined;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAuthSchemeResponseDto extends IResourceDto {
    /** The auth scheme if configured. */
    readonly scheme?: AuthSchemeDto | undefined;
}

export class AuthSchemeDto implements IAuthSchemeDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The domain name of your user accounts. */
    readonly domain!: string;
    /** The display name for buttons. */
    readonly displayName!: string;
    /** The client ID. */
    readonly clientId!: string;
    /** The client secret. */
    readonly clientSecret!: string;
    /** The authority URL. */
    readonly authority!: string;
    /** The URL to redirect after a signout. */
    readonly signoutRedirectUrl?: string | undefined;

    constructor(data?: IAuthSchemeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).domain = _data["domain"];
        (<any>this).displayName = _data["displayName"];
        (<any>this).clientId = _data["clientId"];
        (<any>this).clientSecret = _data["clientSecret"];
        (<any>this).authority = _data["authority"];
        (<any>this).signoutRedirectUrl = _data["signoutRedirectUrl"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AuthSchemeDto {
        const result = new AuthSchemeDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["domain"] = this.domain;
        data["displayName"] = this.displayName;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["authority"] = this.authority;
        data["signoutRedirectUrl"] = this.signoutRedirectUrl;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAuthSchemeDto {
    /** The domain name of your user accounts. */
    readonly domain: string;
    /** The display name for buttons. */
    readonly displayName: string;
    /** The client ID. */
    readonly clientId: string;
    /** The client secret. */
    readonly clientSecret: string;
    /** The authority URL. */
    readonly authority: string;
    /** The URL to redirect after a signout. */
    readonly signoutRedirectUrl?: string | undefined;
}

export class AuthSchemeValueDto implements IAuthSchemeValueDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The auth scheme if configured. */
    readonly scheme?: AuthSchemeDto | undefined;

    constructor(data?: IAuthSchemeValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).scheme = _data["scheme"] ? AuthSchemeDto.fromJSON(_data["scheme"]) : <any>undefined;
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AuthSchemeValueDto {
        const result = new AuthSchemeValueDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["scheme"] = this.scheme ? this.scheme.toJSON() : <any>undefined;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAuthSchemeValueDto {
    /** The auth scheme if configured. */
    readonly scheme?: AuthSchemeDto | undefined;
}

export class LogDownloadDto implements ILogDownloadDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The url to download the log. */
    readonly downloadUrl?: string | undefined;

    constructor(data?: ILogDownloadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).downloadUrl = _data["downloadUrl"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): LogDownloadDto {
        const result = new LogDownloadDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["downloadUrl"] = this.downloadUrl;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ILogDownloadDto {
    /** The url to download the log. */
    readonly downloadUrl?: string | undefined;
}

export class CallsUsageDto implements ICallsUsageDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The total number of API calls. */
    readonly totalCalls!: number;
    /** The total number of bytes transferred. */
    readonly totalBytes!: number;
    /** The total number of API calls this month. */
    readonly monthCalls!: number;
    /** The total number of bytes transferred this month. */
    readonly monthBytes!: number;
    /** The amount of calls that will block the app. */
    readonly blockingApiCalls!: number;
    /** The included API traffic. */
    readonly allowedBytes!: number;
    /** The included API calls. */
    readonly allowedCalls!: number;
    /** The average duration in milliseconds. */
    readonly averageElapsedMs!: number;
    /** The statistics by date and group. */
    readonly details!: { [key: string]: CallsUsagePerDateDto[]; };

    constructor(data?: ICallsUsageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).totalCalls = _data["totalCalls"];
        (<any>this).totalBytes = _data["totalBytes"];
        (<any>this).monthCalls = _data["monthCalls"];
        (<any>this).monthBytes = _data["monthBytes"];
        (<any>this).blockingApiCalls = _data["blockingApiCalls"];
        (<any>this).allowedBytes = _data["allowedBytes"];
        (<any>this).allowedCalls = _data["allowedCalls"];
        (<any>this).averageElapsedMs = _data["averageElapsedMs"];
        if (_data["details"]) {
            (<any>this).details = {} as any;
            for (let key in _data["details"]) {
                if (_data["details"].hasOwnProperty(key))
                    (<any>(<any>this).details)![key] = _data["details"][key] ? _data["details"][key].map((i: any) => CallsUsagePerDateDto.fromJSON(i)) : [];
            }
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CallsUsageDto {
        const result = new CallsUsageDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["totalCalls"] = this.totalCalls;
        data["totalBytes"] = this.totalBytes;
        data["monthCalls"] = this.monthCalls;
        data["monthBytes"] = this.monthBytes;
        data["blockingApiCalls"] = this.blockingApiCalls;
        data["allowedBytes"] = this.allowedBytes;
        data["allowedCalls"] = this.allowedCalls;
        data["averageElapsedMs"] = this.averageElapsedMs;
        if (this.details) {
            data["details"] = {};
            for (let key in this.details) {
                if (this.details.hasOwnProperty(key))
                    (<any>data["details"])[key] = (<any>this.details)[key];
            }
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICallsUsageDto {
    /** The total number of API calls. */
    readonly totalCalls: number;
    /** The total number of bytes transferred. */
    readonly totalBytes: number;
    /** The total number of API calls this month. */
    readonly monthCalls: number;
    /** The total number of bytes transferred this month. */
    readonly monthBytes: number;
    /** The amount of calls that will block the app. */
    readonly blockingApiCalls: number;
    /** The included API traffic. */
    readonly allowedBytes: number;
    /** The included API calls. */
    readonly allowedCalls: number;
    /** The average duration in milliseconds. */
    readonly averageElapsedMs: number;
    /** The statistics by date and group. */
    readonly details: { [key: string]: CallsUsagePerDateDto[]; };
}

export class CallsUsagePerDateDto implements ICallsUsagePerDateDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The date when the usage was tracked. */
    readonly date!: DateTime;
    /** The total number of API calls. */
    readonly totalCalls!: number;
    /** The total number of bytes transferred. */
    readonly totalBytes!: number;
    /** The average duration in milliseconds. */
    readonly averageElapsedMs!: number;

    constructor(data?: ICallsUsagePerDateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).date = _data["date"] ? DateTime.parseISO(_data["date"].toString()) : <any>undefined;
        (<any>this).totalCalls = _data["totalCalls"];
        (<any>this).totalBytes = _data["totalBytes"];
        (<any>this).averageElapsedMs = _data["averageElapsedMs"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CallsUsagePerDateDto {
        const result = new CallsUsagePerDateDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["totalCalls"] = this.totalCalls;
        data["totalBytes"] = this.totalBytes;
        data["averageElapsedMs"] = this.averageElapsedMs;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICallsUsagePerDateDto {
    /** The date when the usage was tracked. */
    readonly date: DateTime;
    /** The total number of API calls. */
    readonly totalCalls: number;
    /** The total number of bytes transferred. */
    readonly totalBytes: number;
    /** The average duration in milliseconds. */
    readonly averageElapsedMs: number;
}

export class CurrentStorageDto implements ICurrentStorageDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The size in bytes. */
    readonly size!: number;
    /** The maximum allowed asset size. */
    readonly maxAllowed!: number;

    constructor(data?: ICurrentStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).size = _data["size"];
        (<any>this).maxAllowed = _data["maxAllowed"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CurrentStorageDto {
        const result = new CurrentStorageDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["size"] = this.size;
        data["maxAllowed"] = this.maxAllowed;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICurrentStorageDto {
    /** The size in bytes. */
    readonly size: number;
    /** The maximum allowed asset size. */
    readonly maxAllowed: number;
}

export class StorageUsagePerDateDto implements IStorageUsagePerDateDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The date when the usage was tracked. */
    readonly date!: DateTime;
    /** The number of assets. */
    readonly totalCount!: number;
    /** The size in bytes. */
    readonly totalSize!: number;

    constructor(data?: IStorageUsagePerDateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).date = _data["date"] ? DateTime.parseISO(_data["date"].toString()) : <any>undefined;
        (<any>this).totalCount = _data["totalCount"];
        (<any>this).totalSize = _data["totalSize"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): StorageUsagePerDateDto {
        const result = new StorageUsagePerDateDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalSize"] = this.totalSize;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IStorageUsagePerDateDto {
    /** The date when the usage was tracked. */
    readonly date: DateTime;
    /** The number of assets. */
    readonly totalCount: number;
    /** The size in bytes. */
    readonly totalSize: number;
}

export class SearchResultDto extends ResourceDto implements ISearchResultDto {
    /** The name of the search result. */
    readonly name!: string;
    /** The type of the search result. */
    readonly type!: SearchResultType;
    /** An optional label. */
    readonly label?: string | undefined;

    get url() {
        return this.compute('url', () => this._links['url'].href);
    }

    constructor(data?: ISearchResultDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).name = _data["name"];
        (<any>this).type = _data["type"];
        (<any>this).label = _data["label"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SearchResultDto {
        const result = new SearchResultDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["type"] = this.type;
        data["label"] = this.label;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISearchResultDto extends IResourceDto {
    /** The name of the search result. */
    readonly name: string;
    /** The type of the search result. */
    readonly type: SearchResultType;
    /** An optional label. */
    readonly label?: string | undefined;
}

export type SearchResultType = "Asset" | "Content" | "Dashboard" | "Setting" | "Rule" | "Schema";

export const SearchResultTypeValues: ReadonlyArray<SearchResultType> = [
	"Asset",
	"Content",
	"Dashboard",
	"Setting",
	"Rule",
	"Schema"
];

export class SchemaDto extends ResourceDto implements ISchemaDto {
    /** The ID of the schema. */
    readonly id!: string;
    /** The user that has created the schema. */
    readonly createdBy!: string;
    /** The user that has updated the schema. */
    readonly lastModifiedBy!: string;
    /** The name of the schema. Unique within the app. */
    readonly name!: string;
    /** The type of the schema. */
    readonly type!: SchemaType;
    /** The name of the category. */
    readonly category?: string | undefined;
    /** The schema properties. */
    readonly properties!: SchemaPropertiesDto;
    /** Indicates if the schema is a singleton. */
    readonly isSingleton!: boolean;
    /** Indicates if the schema is published. */
    readonly isPublished!: boolean;
    /** The date and time when the schema has been created. */
    readonly created!: DateTime;
    /** The date and time when the schema has been modified last. */
    readonly lastModified!: DateTime;
    /** The version of the schema. */
    readonly version!: number;
    /** The scripts. */
    readonly scripts!: SchemaScriptsDto;
    /** The preview Urls. */
    readonly previewUrls!: { [key: string]: string; };
    /** The name of fields that are used in content lists. */
    readonly fieldsInLists!: string[];
    /** The name of fields that are used in content references. */
    readonly fieldsInReferences!: string[];
    /** The field rules. */
    readonly fieldRules!: FieldRuleDto[];
    /** The list of fields. */
    readonly fields!: FieldDto[];

    get canAddField() {
        return this.compute('canAddField', () => hasAnyLink(this._links, 'fields/add'));
    }

    get canContentsCreate() {
        return this.compute('canContentsCreate', () => hasAnyLink(this._links, 'contents/create'));
    }

    get canContentsCreateAndPublish() {
        return this.compute('canContentsCreateAndPublish', () => hasAnyLink(this._links, 'contents/create/publish'));
    }

    get canContentsRead() {
        return this.compute('canContentsCreateAndPublish', () => hasAnyLink(this._links, 'contents'));
    }

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canOrderFields() {
        return this.compute('canOrderFields', () => hasAnyLink(this._links, 'fields/order'));
    }

    get canPublish() {
        return this.compute('canPublish', () => hasAnyLink(this._links, 'publish'));
    }

    get canReadContents() {
        return this.compute('canReadContents', () => hasAnyLink(this._links, 'contents'));
    }

    get canSynchronize() {
        return this.compute('canReadContents', () => hasAnyLink(this._links, 'update/sync'));
    }

    get canUnpublish() {
        return this.compute('canReadContents', () => hasAnyLink(this._links, 'unpublish'));
    }

    get canUpdate() {
        return this.compute('canReadContents', () => hasAnyLink(this._links, 'update'));
    }

    get canUpdateCategory() {
        return this.compute('canUpdateCategory', () => hasAnyLink(this._links, 'update/category'));
    }

    get canUpdateRules() {
        return this.compute('canUpdateCategory', () => hasAnyLink(this._links, 'update/rules'));
    }

    get canUpdateScripts() {
        return this.compute('canUpdateScripts', () => hasAnyLink(this._links, 'update/scripts'));
    }

    get canUpdateUIFields() {
        return this.compute('canUpdateUIFields', () => hasAnyLink(this._links, 'fields/ui'));
    }

    get canUpdateUrls() {
        return this.compute('canUpdateUrls', () => hasAnyLink(this._links, 'update/urls'));
    }

    get displayName() {
        return this.compute('displayName', () => StringHelper.firstNonEmpty(this.properties.label, this.name));
    }

    get contentFields() {
        return this.compute('displayName', () => this.fields.filter(x => x.properties.isContentField).map(tableField));
    }

    get defaultListFields() {
        return this.compute('defaultListFields', () => {
            const listFields = tableFields(this.fieldsInLists, this.contentFields);

            if (listFields.length === 0) {
                listFields.push(META_FIELDS.lastModifiedByAvatar);

                if (this.fields.length > 0) {
                    listFields.push(tableField(this.fields[0]));
                } else {
                    listFields.push(META_FIELDS.empty);
                }

                listFields.push(META_FIELDS.statusColor);
                listFields.push(META_FIELDS.lastModified);
            }

            return listFields;
        });
    }

    get defaultReferenceFields() {
        return this.compute('defaultReferenceFields', () => {
            const referenceFields = tableFields(this.fieldsInReferences, this.contentFields);

            if (referenceFields.length === 0) {
                if (this.fields.length > 0) {
                    referenceFields.push(tableField(this.fields[0]));
                } else {
                    referenceFields.push(META_FIELDS.empty);
                }
            }

            return referenceFields;
        });
    }

    public export(): any {
        const fieldKeys = [
            'fieldId',
            'parentId',
            'parentFieldId',
            '_links',
        ];

        const cleanup = (source: any, ...exclude: string[]): any => {
            const clone = {} as Record<string, any>;

            for (const [key, value] of Object.entries(source)) {
                if (!exclude.includes(key) && key.indexOf('can') !== 0 && !Types.isUndefined(value) && !Types.isNull(value)) {
                    clone[key] = value;
                }
            }

            return clone;
        };

        const result: any = {
            previewUrls: this.previewUrls,
            properties: cleanup(this.properties),
            category: this.category,
            scripts: this.scripts,
            isPublished: this.isPublished,
            fieldRules: this.fieldRules,
            fieldsInLists: this.fieldsInLists,
            fieldsInReferences: this.fieldsInReferences,
            fields: this.fields.map(field => {
                const copy = cleanup(field, ...fieldKeys);

                copy.properties = cleanup(field.properties);

                if (Types.isArray(copy.nested)) {
                    if (copy.nested.length === 0) {
                        delete copy['nested'];
                    } else if (field.nested) {
                        copy.nested = field.nested.map(nestedField => {
                            const nestedCopy = cleanup(nestedField, ...fieldKeys);

                            nestedCopy.properties = cleanup(nestedField.properties);

                            return nestedCopy;
                        });
                    }
                }

                return copy;
            }),
            type: this.type,
        };

        return result;
    }

    constructor(data?: ISchemaDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).createdBy = _data["createdBy"];
        (<any>this).lastModifiedBy = _data["lastModifiedBy"];
        (<any>this).name = _data["name"];
        (<any>this).type = _data["type"];
        (<any>this).category = _data["category"];
        (<any>this).properties = _data["properties"] ? SchemaPropertiesDto.fromJSON(_data["properties"]) : new SchemaPropertiesDto();
        (<any>this).isSingleton = _data["isSingleton"];
        (<any>this).isPublished = _data["isPublished"];
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).lastModified = _data["lastModified"] ? DateTime.parseISO(_data["lastModified"].toString()) : <any>undefined;
        (<any>this).version = _data["version"];
        (<any>this).scripts = _data["scripts"] ? SchemaScriptsDto.fromJSON(_data["scripts"]) : new SchemaScriptsDto();
        if (_data["previewUrls"]) {
            (<any>this).previewUrls = {} as any;
            for (let key in _data["previewUrls"]) {
                if (_data["previewUrls"].hasOwnProperty(key))
                    (<any>(<any>this).previewUrls)![key] = _data["previewUrls"][key];
            }
        }
        if (Array.isArray(_data["fieldsInLists"])) {
            (<any>this).fieldsInLists = [] as any;
            for (let item of _data["fieldsInLists"])
                (<any>this).fieldsInLists!.push(item);
        }
        if (Array.isArray(_data["fieldsInReferences"])) {
            (<any>this).fieldsInReferences = [] as any;
            for (let item of _data["fieldsInReferences"])
                (<any>this).fieldsInReferences!.push(item);
        }
        if (Array.isArray(_data["fieldRules"])) {
            (<any>this).fieldRules = [] as any;
            for (let item of _data["fieldRules"])
                (<any>this).fieldRules!.push(FieldRuleDto.fromJSON(item));
        }
        if (Array.isArray(_data["fields"])) {
            (<any>this).fields = [] as any;
            for (let item of _data["fields"])
                (<any>this).fields!.push(FieldDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SchemaDto {
        const result = new SchemaDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["name"] = this.name;
        data["type"] = this.type;
        data["category"] = this.category;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["isSingleton"] = this.isSingleton;
        data["isPublished"] = this.isPublished;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["scripts"] = this.scripts ? this.scripts.toJSON() : <any>undefined;
        if (this.previewUrls) {
            data["previewUrls"] = {};
            for (let key in this.previewUrls) {
                if (this.previewUrls.hasOwnProperty(key))
                    (<any>data["previewUrls"])[key] = (<any>this.previewUrls)[key];
            }
        }
        if (Array.isArray(this.fieldsInLists)) {
            data["fieldsInLists"] = [];
            for (let item of this.fieldsInLists)
                data["fieldsInLists"].push(item);
        }
        if (Array.isArray(this.fieldsInReferences)) {
            data["fieldsInReferences"] = [];
            for (let item of this.fieldsInReferences)
                data["fieldsInReferences"].push(item);
        }
        if (Array.isArray(this.fieldRules)) {
            data["fieldRules"] = [];
            for (let item of this.fieldRules)
                data["fieldRules"].push(item.toJSON());
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISchemaDto extends IResourceDto {
    /** The ID of the schema. */
    readonly id: string;
    /** The user that has created the schema. */
    readonly createdBy: string;
    /** The user that has updated the schema. */
    readonly lastModifiedBy: string;
    /** The name of the schema. Unique within the app. */
    readonly name: string;
    /** The type of the schema. */
    readonly type: SchemaType;
    /** The name of the category. */
    readonly category?: string | undefined;
    /** The schema properties. */
    readonly properties: SchemaPropertiesDto;
    /** Indicates if the schema is a singleton. */
    readonly isSingleton: boolean;
    /** Indicates if the schema is published. */
    readonly isPublished: boolean;
    /** The date and time when the schema has been created. */
    readonly created: DateTime;
    /** The date and time when the schema has been modified last. */
    readonly lastModified: DateTime;
    /** The version of the schema. */
    readonly version: number;
    /** The scripts. */
    readonly scripts: SchemaScriptsDto;
    /** The preview Urls. */
    readonly previewUrls: { [key: string]: string; };
    /** The name of fields that are used in content lists. */
    readonly fieldsInLists: string[];
    /** The name of fields that are used in content references. */
    readonly fieldsInReferences: string[];
    /** The field rules. */
    readonly fieldRules: FieldRuleDto[];
    /** The list of fields. */
    readonly fields: FieldDto[];
}

export type SchemaType = "Default" | "Singleton" | "Component";

export const SchemaTypeValues: ReadonlyArray<SchemaType> = [
	"Default",
	"Singleton",
	"Component"
];

export class SchemaPropertiesDto implements ISchemaPropertiesDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Optional label for the editor. */
    readonly label?: string | undefined;
    /** Hints to describe the schema. */
    readonly hints?: string | undefined;
    /** The url to a the sidebar plugin for content lists. */
    readonly contentsSidebarUrl?: string | undefined;
    /** The url to a the sidebar plugin for content items. */
    readonly contentSidebarUrl?: string | undefined;
    /** The url to the editor plugin. */
    readonly contentEditorUrl?: string | undefined;
    /** The url to the editor plugin. */
    readonly contentsEditorUrl?: string | undefined;
    /** The url to the content list plugin. */
    readonly contentsListUrl?: string | undefined;
    /** True to validate the content items on publish. */
    readonly validateOnPublish!: boolean;
    /** Tags for automation processes. */
    readonly tags?: string[] | undefined;

    constructor(data?: ISchemaPropertiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).label = _data["label"];
        (<any>this).hints = _data["hints"];
        (<any>this).contentsSidebarUrl = _data["contentsSidebarUrl"];
        (<any>this).contentSidebarUrl = _data["contentSidebarUrl"];
        (<any>this).contentEditorUrl = _data["contentEditorUrl"];
        (<any>this).contentsEditorUrl = _data["contentsEditorUrl"];
        (<any>this).contentsListUrl = _data["contentsListUrl"];
        (<any>this).validateOnPublish = _data["validateOnPublish"];
        if (Array.isArray(_data["tags"])) {
            (<any>this).tags = [] as any;
            for (let item of _data["tags"])
                (<any>this).tags!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SchemaPropertiesDto {
        const result = new SchemaPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["label"] = this.label;
        data["hints"] = this.hints;
        data["contentsSidebarUrl"] = this.contentsSidebarUrl;
        data["contentSidebarUrl"] = this.contentSidebarUrl;
        data["contentEditorUrl"] = this.contentEditorUrl;
        data["contentsEditorUrl"] = this.contentsEditorUrl;
        data["contentsListUrl"] = this.contentsListUrl;
        data["validateOnPublish"] = this.validateOnPublish;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ISchemaPropertiesDto {
    /** Optional label for the editor. */
    readonly label?: string | undefined;
    /** Hints to describe the schema. */
    readonly hints?: string | undefined;
    /** The url to a the sidebar plugin for content lists. */
    readonly contentsSidebarUrl?: string | undefined;
    /** The url to a the sidebar plugin for content items. */
    readonly contentSidebarUrl?: string | undefined;
    /** The url to the editor plugin. */
    readonly contentEditorUrl?: string | undefined;
    /** The url to the editor plugin. */
    readonly contentsEditorUrl?: string | undefined;
    /** The url to the content list plugin. */
    readonly contentsListUrl?: string | undefined;
    /** True to validate the content items on publish. */
    readonly validateOnPublish: boolean;
    /** Tags for automation processes. */
    readonly tags?: string[] | undefined;
}

export class SchemaScriptsDto implements ISchemaScriptsDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The script that is executed for each content when querying contents. */
    readonly query?: string | undefined;
    /** The script that is executed for all contents when querying contents. */
    readonly queryPre?: string | undefined;
    /** The script that is executed when creating a content. */
    readonly create?: string | undefined;
    /** The script that is executed when updating a content. */
    readonly update?: string | undefined;
    /** The script that is executed when deleting a content. */
    readonly delete?: string | undefined;
    /** The script that is executed when change a content status. */
    readonly change?: string | undefined;

    constructor(data?: ISchemaScriptsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).query = _data["query"];
        (<any>this).queryPre = _data["queryPre"];
        (<any>this).create = _data["create"];
        (<any>this).update = _data["update"];
        (<any>this).delete = _data["delete"];
        (<any>this).change = _data["change"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SchemaScriptsDto {
        const result = new SchemaScriptsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["query"] = this.query;
        data["queryPre"] = this.queryPre;
        data["create"] = this.create;
        data["update"] = this.update;
        data["delete"] = this.delete;
        data["change"] = this.change;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ISchemaScriptsDto {
    /** The script that is executed for each content when querying contents. */
    readonly query?: string | undefined;
    /** The script that is executed for all contents when querying contents. */
    readonly queryPre?: string | undefined;
    /** The script that is executed when creating a content. */
    readonly create?: string | undefined;
    /** The script that is executed when updating a content. */
    readonly update?: string | undefined;
    /** The script that is executed when deleting a content. */
    readonly delete?: string | undefined;
    /** The script that is executed when change a content status. */
    readonly change?: string | undefined;
}

export class FieldRuleDto implements IFieldRuleDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The action to perform when the condition is met. */
    readonly action!: FieldRuleAction;
    /** The field to update. */
    readonly field!: string;
    /** The condition. */
    readonly condition?: string | undefined;

    constructor(data?: IFieldRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).action = _data["action"];
        (<any>this).field = _data["field"];
        (<any>this).condition = _data["condition"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FieldRuleDto {
        const result = new FieldRuleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["action"] = this.action;
        data["field"] = this.field;
        data["condition"] = this.condition;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFieldRuleDto {
    /** The action to perform when the condition is met. */
    readonly action: FieldRuleAction;
    /** The field to update. */
    readonly field: string;
    /** The condition. */
    readonly condition?: string | undefined;
}

export type FieldRuleAction = "Disable" | "Hide" | "Require";

export const FieldRuleActionValues: ReadonlyArray<FieldRuleAction> = [
	"Disable",
	"Hide",
	"Require"
];

export class FieldDto extends ResourceDto implements IFieldDto {
    /** The ID of the field. */
    readonly fieldId!: number;
    /** The name of the field. Must be unique within the schema. */
    readonly name!: string;
    /** Defines if the field is hidden. */
    readonly isHidden!: boolean;
    /** Defines if the field is locked. */
    readonly isLocked!: boolean;
    /** Defines if the field is disabled. */
    readonly isDisabled!: boolean;
    /** Defines the partitioning of the field. */
    readonly partitioning!: string;
    /** The field properties. */
    readonly properties!: FieldPropertiesDto;
    /** The nested fields. */
    readonly nested?: NestedFieldDto[] | undefined;

    public get rawProperties(): any {
        return this.properties;
    }

    public get isInlineEditable(): boolean {
        return this.compute('isInlineEditable', () => !this.isDisabled && this.rawProperties.inlineEditable === true);
    }

    public get isInvariant(): boolean {
        return this.compute('isInvariant', () => this.partitioning === 'invariant');
    }

    public get isLocalizable(): boolean {
        return this.compute('isLocalizable', () => this.partitioning === 'language');
    }

    public get displayName() {
        return this.compute('displayName', () => StringHelper.firstNonEmpty(this.properties.label, this.name));
    }

    public get displayPlaceholder() {
        return this.compute('displayPlaceholder', () => this.properties.placeholder || '');
    }

    get canAddField() {
        return this.compute('canAddField', () => hasAnyLink(this._links, 'fields/add'));
    }

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canDisable() {
        return this.compute('canDisable', () => hasAnyLink(this._links, 'disable'));
    }

    get canEnable() {
        return this.compute('canEnable', () => hasAnyLink(this._links, 'enable'));
    }

    get canOrderFields() {
        return this.compute('canOrderFields', () => hasAnyLink(this._links, 'fields/order'));
    }

    get canHide() {
        return this.compute('canHide', () => hasAnyLink(this._links, 'hide'));
    }

    get canLock() {
        return this.compute('canLock', () => hasAnyLink(this._links, 'lock'));
    }

    get canShow() {
        return this.compute('canShow', () => hasAnyLink(this._links, 'show'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IFieldDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).fieldId = _data["fieldId"];
        (<any>this).name = _data["name"];
        (<any>this).isHidden = _data["isHidden"];
        (<any>this).isLocked = _data["isLocked"];
        (<any>this).isDisabled = _data["isDisabled"];
        (<any>this).partitioning = _data["partitioning"];
        (<any>this).properties = _data["properties"] ? FieldPropertiesDto.fromJSON(_data["properties"]) : <any>undefined;
        if (Array.isArray(_data["nested"])) {
            (<any>this).nested = [] as any;
            for (let item of _data["nested"])
                (<any>this).nested!.push(NestedFieldDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FieldDto {
        const result = new FieldDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["fieldId"] = this.fieldId;
        data["name"] = this.name;
        data["isHidden"] = this.isHidden;
        data["isLocked"] = this.isLocked;
        data["isDisabled"] = this.isDisabled;
        data["partitioning"] = this.partitioning;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        if (Array.isArray(this.nested)) {
            data["nested"] = [];
            for (let item of this.nested)
                data["nested"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IFieldDto extends IResourceDto {
    /** The ID of the field. */
    readonly fieldId: number;
    /** The name of the field. Must be unique within the schema. */
    readonly name: string;
    /** Defines if the field is hidden. */
    readonly isHidden: boolean;
    /** Defines if the field is locked. */
    readonly isLocked: boolean;
    /** Defines if the field is disabled. */
    readonly isDisabled: boolean;
    /** Defines the partitioning of the field. */
    readonly partitioning: string;
    /** The field properties. */
    readonly properties: FieldPropertiesDto;
    /** The nested fields. */
    readonly nested?: NestedFieldDto[] | undefined;
}

export abstract class FieldPropertiesDto implements IFieldPropertiesDto {
    /** The discriminator. */
    public readonly fieldType!: string;
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Optional label for the editor. */
    readonly label?: string | undefined;
    /** Hints to describe the field. */
    readonly hints?: string | undefined;
    /** Placeholder to show when no value has been entered. */
    readonly placeholder?: string | undefined;
    /** Indicates if the field is required. */
    readonly isRequired?: boolean;
    /** Indicates if the field is required when publishing. */
    readonly isRequiredOnPublish?: boolean;
    /** Indicates if the field should be rendered with half width only. */
    readonly isHalfWidth?: boolean;
    /** Optional url to the editor. */
    readonly editorUrl?: string | undefined;
    /** Tags for automation processes. */
    readonly tags?: string[] | undefined;

    public get isComplexUI() {
        return true;
    }

    public get isSortable() {
        return true;
    }

    public get isContentField() {
        return true;
    }

    public accept<T>(_visitor: FieldPropertiesVisitor<T>): T {
        throw new Error('NOT IMPLEMENTED');
    }

    constructor(data?: IFieldPropertiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        (<any>this).fieldType = "FieldPropertiesDto";
    }

    init(_data: any) {
        (<any>this).label = _data["label"];
        (<any>this).hints = _data["hints"];
        (<any>this).placeholder = _data["placeholder"];
        (<any>this).isRequired = _data["isRequired"];
        (<any>this).isRequiredOnPublish = _data["isRequiredOnPublish"];
        (<any>this).isHalfWidth = _data["isHalfWidth"];
        (<any>this).editorUrl = _data["editorUrl"];
        if (Array.isArray(_data["tags"])) {
            (<any>this).tags = [] as any;
            for (let item of _data["tags"])
                (<any>this).tags!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FieldPropertiesDto {
        if (data["fieldType"] === "Array") {
            return new ArrayFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "Assets") {
            return new AssetsFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "Boolean") {
            return new BooleanFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "Component") {
            return new ComponentFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "Components") {
            return new ComponentsFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "DateTime") {
            return new DateTimeFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "Geolocation") {
            return new GeolocationFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "Json") {
            return new JsonFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "Number") {
            return new NumberFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "References") {
            return new ReferencesFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "RichText") {
            return new RichTextFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "String") {
            return new StringFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "Tags") {
            return new TagsFieldPropertiesDto().init(data);
        }
        if (data["fieldType"] === "UI") {
            return new UIFieldPropertiesDto().init(data);
        }
        throw new Error("The abstract class 'FieldPropertiesDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["fieldType"] = this.fieldType;
        data["label"] = this.label;
        data["hints"] = this.hints;
        data["placeholder"] = this.placeholder;
        data["isRequired"] = this.isRequired;
        data["isRequiredOnPublish"] = this.isRequiredOnPublish;
        data["isHalfWidth"] = this.isHalfWidth;
        data["editorUrl"] = this.editorUrl;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFieldPropertiesDto {
    /** Optional label for the editor. */
    readonly label?: string | undefined;
    /** Hints to describe the field. */
    readonly hints?: string | undefined;
    /** Placeholder to show when no value has been entered. */
    readonly placeholder?: string | undefined;
    /** Indicates if the field is required. */
    readonly isRequired?: boolean;
    /** Indicates if the field is required when publishing. */
    readonly isRequiredOnPublish?: boolean;
    /** Indicates if the field should be rendered with half width only. */
    readonly isHalfWidth?: boolean;
    /** Optional url to the editor. */
    readonly editorUrl?: string | undefined;
    /** Tags for automation processes. */
    readonly tags?: string[] | undefined;
}

export class ArrayFieldPropertiesDto extends FieldPropertiesDto implements IArrayFieldPropertiesDto {
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** The calculated default value for the field value. */
    readonly calculatedDefaultValue?: ArrayCalculatedDefaultValue;
    /** The fields that must be unique. */
    readonly uniqueFields?: string[] | undefined;

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitArray(this);
    }

    constructor(data?: IArrayFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "Array";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).minItems = _data["minItems"];
        (<any>this).maxItems = _data["maxItems"];
        (<any>this).calculatedDefaultValue = _data["calculatedDefaultValue"];
        if (Array.isArray(_data["uniqueFields"])) {
            (<any>this).uniqueFields = [] as any;
            for (let item of _data["uniqueFields"])
                (<any>this).uniqueFields!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ArrayFieldPropertiesDto {
        const result = new ArrayFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["minItems"] = this.minItems;
        data["maxItems"] = this.maxItems;
        data["calculatedDefaultValue"] = this.calculatedDefaultValue;
        if (Array.isArray(this.uniqueFields)) {
            data["uniqueFields"] = [];
            for (let item of this.uniqueFields)
                data["uniqueFields"].push(item);
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IArrayFieldPropertiesDto extends IFieldPropertiesDto {
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** The calculated default value for the field value. */
    readonly calculatedDefaultValue?: ArrayCalculatedDefaultValue;
    /** The fields that must be unique. */
    readonly uniqueFields?: string[] | undefined;
}

export type ArrayCalculatedDefaultValue = "EmptyArray" | "Null";

export const ArrayCalculatedDefaultValueValues: ReadonlyArray<ArrayCalculatedDefaultValue> = [
	"EmptyArray",
	"Null"
];

export class AssetsFieldPropertiesDto extends FieldPropertiesDto implements IAssetsFieldPropertiesDto {
    /** The preview mode for the asset. */
    readonly previewMode?: AssetPreviewMode;
    /** The language specific default value as a list of asset ids. */
    readonly defaultValues?: { [key: string]: string[]; } | undefined;
    /** The default value as a list of asset ids. */
    readonly defaultValue?: string[] | undefined;
    /** The initial id to the folder. */
    readonly folderId?: string | undefined;
    /** The preview format. */
    readonly previewFormat?: string | undefined;
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** The minimum file size in bytes. */
    readonly minSize?: number | undefined;
    /** The maximum file size in bytes. */
    readonly maxSize?: number | undefined;
    /** The minimum image width in pixels. */
    readonly minWidth?: number | undefined;
    /** The maximum image width in pixels. */
    readonly maxWidth?: number | undefined;
    /** The minimum image height in pixels. */
    readonly minHeight?: number | undefined;
    /** The maximum image height in pixels. */
    readonly maxHeight?: number | undefined;
    /** The image aspect width in pixels. */
    readonly aspectWidth?: number | undefined;
    /** The image aspect height in pixels. */
    readonly aspectHeight?: number | undefined;
    /** The expected type. */
    readonly expectedType?: AssetType | undefined;
    /** True to resolve first asset in the content list. */
    readonly resolveFirst?: boolean;
    /** True to resolve first image in the content list. */
    readonly mustBeImage?: boolean;
    /** True to resolve first image in the content list. */
    readonly resolveImage?: boolean;
    /** The allowed file extensions. */
    readonly allowedExtensions?: string[] | undefined;
    /** True, if duplicate values are allowed. */
    readonly allowDuplicates?: boolean;

    public get isSortable() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitAssets(this);
    }

    constructor(data?: IAssetsFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "Assets";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).previewMode = _data["previewMode"];
        if (_data["defaultValues"]) {
            (<any>this).defaultValues = {} as any;
            for (let key in _data["defaultValues"]) {
                if (_data["defaultValues"].hasOwnProperty(key))
                    (<any>(<any>this).defaultValues)![key] = _data["defaultValues"][key] !== undefined ? _data["defaultValues"][key] : [];
            }
        }
        if (Array.isArray(_data["defaultValue"])) {
            (<any>this).defaultValue = [] as any;
            for (let item of _data["defaultValue"])
                (<any>this).defaultValue!.push(item);
        }
        (<any>this).folderId = _data["folderId"];
        (<any>this).previewFormat = _data["previewFormat"];
        (<any>this).minItems = _data["minItems"];
        (<any>this).maxItems = _data["maxItems"];
        (<any>this).minSize = _data["minSize"];
        (<any>this).maxSize = _data["maxSize"];
        (<any>this).minWidth = _data["minWidth"];
        (<any>this).maxWidth = _data["maxWidth"];
        (<any>this).minHeight = _data["minHeight"];
        (<any>this).maxHeight = _data["maxHeight"];
        (<any>this).aspectWidth = _data["aspectWidth"];
        (<any>this).aspectHeight = _data["aspectHeight"];
        (<any>this).expectedType = _data["expectedType"];
        (<any>this).resolveFirst = _data["resolveFirst"];
        (<any>this).mustBeImage = _data["mustBeImage"];
        (<any>this).resolveImage = _data["resolveImage"];
        if (Array.isArray(_data["allowedExtensions"])) {
            (<any>this).allowedExtensions = [] as any;
            for (let item of _data["allowedExtensions"])
                (<any>this).allowedExtensions!.push(item);
        }
        (<any>this).allowDuplicates = _data["allowDuplicates"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AssetsFieldPropertiesDto {
        const result = new AssetsFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["previewMode"] = this.previewMode;
        if (this.defaultValues) {
            data["defaultValues"] = {};
            for (let key in this.defaultValues) {
                if (this.defaultValues.hasOwnProperty(key))
                    (<any>data["defaultValues"])[key] = (<any>this.defaultValues)[key];
            }
        }
        if (Array.isArray(this.defaultValue)) {
            data["defaultValue"] = [];
            for (let item of this.defaultValue)
                data["defaultValue"].push(item);
        }
        data["folderId"] = this.folderId;
        data["previewFormat"] = this.previewFormat;
        data["minItems"] = this.minItems;
        data["maxItems"] = this.maxItems;
        data["minSize"] = this.minSize;
        data["maxSize"] = this.maxSize;
        data["minWidth"] = this.minWidth;
        data["maxWidth"] = this.maxWidth;
        data["minHeight"] = this.minHeight;
        data["maxHeight"] = this.maxHeight;
        data["aspectWidth"] = this.aspectWidth;
        data["aspectHeight"] = this.aspectHeight;
        data["expectedType"] = this.expectedType;
        data["resolveFirst"] = this.resolveFirst;
        data["mustBeImage"] = this.mustBeImage;
        data["resolveImage"] = this.resolveImage;
        if (Array.isArray(this.allowedExtensions)) {
            data["allowedExtensions"] = [];
            for (let item of this.allowedExtensions)
                data["allowedExtensions"].push(item);
        }
        data["allowDuplicates"] = this.allowDuplicates;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAssetsFieldPropertiesDto extends IFieldPropertiesDto {
    /** The preview mode for the asset. */
    readonly previewMode?: AssetPreviewMode;
    /** The language specific default value as a list of asset ids. */
    readonly defaultValues?: { [key: string]: string[]; } | undefined;
    /** The default value as a list of asset ids. */
    readonly defaultValue?: string[] | undefined;
    /** The initial id to the folder. */
    readonly folderId?: string | undefined;
    /** The preview format. */
    readonly previewFormat?: string | undefined;
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** The minimum file size in bytes. */
    readonly minSize?: number | undefined;
    /** The maximum file size in bytes. */
    readonly maxSize?: number | undefined;
    /** The minimum image width in pixels. */
    readonly minWidth?: number | undefined;
    /** The maximum image width in pixels. */
    readonly maxWidth?: number | undefined;
    /** The minimum image height in pixels. */
    readonly minHeight?: number | undefined;
    /** The maximum image height in pixels. */
    readonly maxHeight?: number | undefined;
    /** The image aspect width in pixels. */
    readonly aspectWidth?: number | undefined;
    /** The image aspect height in pixels. */
    readonly aspectHeight?: number | undefined;
    /** The expected type. */
    readonly expectedType?: AssetType | undefined;
    /** True to resolve first asset in the content list. */
    readonly resolveFirst?: boolean;
    /** True to resolve first image in the content list. */
    readonly mustBeImage?: boolean;
    /** True to resolve first image in the content list. */
    readonly resolveImage?: boolean;
    /** The allowed file extensions. */
    readonly allowedExtensions?: string[] | undefined;
    /** True, if duplicate values are allowed. */
    readonly allowDuplicates?: boolean;
}

export type AssetPreviewMode = "ImageAndFileName" | "Image" | "FileName";

export const AssetPreviewModeValues: ReadonlyArray<AssetPreviewMode> = [
	"ImageAndFileName",
	"Image",
	"FileName"
];

export type AssetType = "Unknown" | "Image" | "Audio" | "Video";

export const AssetTypeValues: ReadonlyArray<AssetType> = [
	"Unknown",
	"Image",
	"Audio",
	"Video"
];

export class BooleanFieldPropertiesDto extends FieldPropertiesDto implements IBooleanFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: boolean; } | undefined;
    /** The default value for the field value. */
    readonly defaultValue?: boolean | undefined;
    /** Indicates that the inline editor is enabled for this field. */
    readonly inlineEditable?: boolean;
    /** The editor that is used to manage this field. */
    readonly editor?: BooleanFieldEditor;

    public get isComplexUI() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitBoolean(this);
    }

    constructor(data?: IBooleanFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "Boolean";
    }

    init(_data: any) {
        super.init(_data);
        if (_data["defaultValues"]) {
            (<any>this).defaultValues = {} as any;
            for (let key in _data["defaultValues"]) {
                if (_data["defaultValues"].hasOwnProperty(key))
                    (<any>(<any>this).defaultValues)![key] = _data["defaultValues"][key];
            }
        }
        (<any>this).defaultValue = _data["defaultValue"];
        (<any>this).inlineEditable = _data["inlineEditable"];
        (<any>this).editor = _data["editor"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): BooleanFieldPropertiesDto {
        const result = new BooleanFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this.defaultValues) {
            data["defaultValues"] = {};
            for (let key in this.defaultValues) {
                if (this.defaultValues.hasOwnProperty(key))
                    (<any>data["defaultValues"])[key] = (<any>this.defaultValues)[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        data["inlineEditable"] = this.inlineEditable;
        data["editor"] = this.editor;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IBooleanFieldPropertiesDto extends IFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: boolean; } | undefined;
    /** The default value for the field value. */
    readonly defaultValue?: boolean | undefined;
    /** Indicates that the inline editor is enabled for this field. */
    readonly inlineEditable?: boolean;
    /** The editor that is used to manage this field. */
    readonly editor?: BooleanFieldEditor;
}

export type BooleanFieldEditor = "Checkbox" | "Toggle";

export const BooleanFieldEditorValues: ReadonlyArray<BooleanFieldEditor> = [
	"Checkbox",
	"Toggle"
];

export class ComponentFieldPropertiesDto extends FieldPropertiesDto implements IComponentFieldPropertiesDto {
    /** The ID of the embedded schemas. */
    readonly schemaIds?: string[] | undefined;

    public get isComplexUI() {
        return true;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitComponent(this);
    }

    constructor(data?: IComponentFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "Component";
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["schemaIds"])) {
            (<any>this).schemaIds = [] as any;
            for (let item of _data["schemaIds"])
                (<any>this).schemaIds!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ComponentFieldPropertiesDto {
        const result = new ComponentFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IComponentFieldPropertiesDto extends IFieldPropertiesDto {
    /** The ID of the embedded schemas. */
    readonly schemaIds?: string[] | undefined;
}

export class ComponentsFieldPropertiesDto extends FieldPropertiesDto implements IComponentsFieldPropertiesDto {
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** The calculated default value for the field value. */
    readonly calculatedDefaultValue?: ArrayCalculatedDefaultValue;
    /** The ID of the embedded schemas. */
    readonly schemaIds?: string[] | undefined;
    /** The fields that must be unique. */
    readonly uniqueFields?: string[] | undefined;

    public get isComplexUI() {
        return true;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitComponents(this);
    }

    constructor(data?: IComponentsFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "Components";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).minItems = _data["minItems"];
        (<any>this).maxItems = _data["maxItems"];
        (<any>this).calculatedDefaultValue = _data["calculatedDefaultValue"];
        if (Array.isArray(_data["schemaIds"])) {
            (<any>this).schemaIds = [] as any;
            for (let item of _data["schemaIds"])
                (<any>this).schemaIds!.push(item);
        }
        if (Array.isArray(_data["uniqueFields"])) {
            (<any>this).uniqueFields = [] as any;
            for (let item of _data["uniqueFields"])
                (<any>this).uniqueFields!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ComponentsFieldPropertiesDto {
        const result = new ComponentsFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["minItems"] = this.minItems;
        data["maxItems"] = this.maxItems;
        data["calculatedDefaultValue"] = this.calculatedDefaultValue;
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        if (Array.isArray(this.uniqueFields)) {
            data["uniqueFields"] = [];
            for (let item of this.uniqueFields)
                data["uniqueFields"].push(item);
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IComponentsFieldPropertiesDto extends IFieldPropertiesDto {
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** The calculated default value for the field value. */
    readonly calculatedDefaultValue?: ArrayCalculatedDefaultValue;
    /** The ID of the embedded schemas. */
    readonly schemaIds?: string[] | undefined;
    /** The fields that must be unique. */
    readonly uniqueFields?: string[] | undefined;
}

export class DateTimeFieldPropertiesDto extends FieldPropertiesDto implements IDateTimeFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: DateTime; } | undefined;
    /** The default value for the field value. */
    readonly defaultValue?: DateTime | undefined;
    /** The maximum allowed value for the field value. */
    readonly maxValue?: DateTime | undefined;
    /** The minimum allowed value for the field value. */
    readonly minValue?: DateTime | undefined;
    /** The format pattern when displayed in the UI. */
    readonly format?: string | undefined;
    /** The editor that is used to manage this field. */
    readonly editor?: DateTimeFieldEditor;
    /** The calculated default value for the field value. */
    readonly calculatedDefaultValue?: DateTimeCalculatedDefaultValue | undefined;

    public get isComplexUI() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitDateTime(this);
    }

    constructor(data?: IDateTimeFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "DateTime";
    }

    init(_data: any) {
        super.init(_data);
        if (_data["defaultValues"]) {
            (<any>this).defaultValues = {} as any;
            for (let key in _data["defaultValues"]) {
                if (_data["defaultValues"].hasOwnProperty(key))
                    (<any>(<any>this).defaultValues)![key] = _data["defaultValues"][key] ? DateTime.parseISO(_data["defaultValues"][key].toString()) : <any>undefined;
            }
        }
        (<any>this).defaultValue = _data["defaultValue"] ? DateTime.parseISO(_data["defaultValue"].toString()) : <any>undefined;
        (<any>this).maxValue = _data["maxValue"] ? DateTime.parseISO(_data["maxValue"].toString()) : <any>undefined;
        (<any>this).minValue = _data["minValue"] ? DateTime.parseISO(_data["minValue"].toString()) : <any>undefined;
        (<any>this).format = _data["format"];
        (<any>this).editor = _data["editor"];
        (<any>this).calculatedDefaultValue = _data["calculatedDefaultValue"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DateTimeFieldPropertiesDto {
        const result = new DateTimeFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this.defaultValues) {
            data["defaultValues"] = {};
            for (let key in this.defaultValues) {
                if (this.defaultValues.hasOwnProperty(key))
                    (<any>data["defaultValues"])[key] = this.defaultValues[key] ? this.defaultValues[key].toISOString() : <any>undefined;
            }
        }
        data["defaultValue"] = this.defaultValue ? this.defaultValue.toISOString() : <any>undefined;
        data["maxValue"] = this.maxValue ? this.maxValue.toISOString() : <any>undefined;
        data["minValue"] = this.minValue ? this.minValue.toISOString() : <any>undefined;
        data["format"] = this.format;
        data["editor"] = this.editor;
        data["calculatedDefaultValue"] = this.calculatedDefaultValue;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IDateTimeFieldPropertiesDto extends IFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: DateTime; } | undefined;
    /** The default value for the field value. */
    readonly defaultValue?: DateTime | undefined;
    /** The maximum allowed value for the field value. */
    readonly maxValue?: DateTime | undefined;
    /** The minimum allowed value for the field value. */
    readonly minValue?: DateTime | undefined;
    /** The format pattern when displayed in the UI. */
    readonly format?: string | undefined;
    /** The editor that is used to manage this field. */
    readonly editor?: DateTimeFieldEditor;
    /** The calculated default value for the field value. */
    readonly calculatedDefaultValue?: DateTimeCalculatedDefaultValue | undefined;
}

export type DateTimeFieldEditor = "Date" | "DateTime";

export const DateTimeFieldEditorValues: ReadonlyArray<DateTimeFieldEditor> = [
	"Date",
	"DateTime"
];

export type DateTimeCalculatedDefaultValue = "Now" | "Today";

export const DateTimeCalculatedDefaultValueValues: ReadonlyArray<DateTimeCalculatedDefaultValue> = [
	"Now",
	"Today"
];

export class GeolocationFieldPropertiesDto extends FieldPropertiesDto implements IGeolocationFieldPropertiesDto {
    /** The editor that is used to manage this field. */
    readonly editor?: GeolocationFieldEditor;

    public get isSortable() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitGeolocation(this);
    }

    constructor(data?: IGeolocationFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "Geolocation";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).editor = _data["editor"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): GeolocationFieldPropertiesDto {
        const result = new GeolocationFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["editor"] = this.editor;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IGeolocationFieldPropertiesDto extends IFieldPropertiesDto {
    /** The editor that is used to manage this field. */
    readonly editor?: GeolocationFieldEditor;
}

export type GeolocationFieldEditor = "Map";

export const GeolocationFieldEditorValues: ReadonlyArray<GeolocationFieldEditor> = [
	"Map"
];

export class JsonFieldPropertiesDto extends FieldPropertiesDto implements IJsonFieldPropertiesDto {
    /** The GraphQL schema. */
    readonly graphQLSchema?: string | undefined;

    public get isSortable() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitJson(this);
    }

    constructor(data?: IJsonFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "Json";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).graphQLSchema = _data["graphQLSchema"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): JsonFieldPropertiesDto {
        const result = new JsonFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["graphQLSchema"] = this.graphQLSchema;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IJsonFieldPropertiesDto extends IFieldPropertiesDto {
    /** The GraphQL schema. */
    readonly graphQLSchema?: string | undefined;
}

export class NumberFieldPropertiesDto extends FieldPropertiesDto implements INumberFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: number; } | undefined;
    /** The default value for the field value. */
    readonly defaultValue?: number | undefined;
    /** The maximum allowed value for the field value. */
    readonly maxValue?: number | undefined;
    /** The minimum allowed value for the field value. */
    readonly minValue?: number | undefined;
    /** The allowed values for the field value. */
    readonly allowedValues?: number[] | undefined;
    /** Indicates if the field value must be unique. Ignored for nested fields and localized fields. */
    readonly isUnique?: boolean;
    /** Indicates that the inline editor is enabled for this field. */
    readonly inlineEditable?: boolean;
    /** The editor that is used to manage this field. */
    readonly editor?: NumberFieldEditor;

    public get isComplexUI() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitNumber(this);
    }

    constructor(data?: INumberFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "Number";
    }

    init(_data: any) {
        super.init(_data);
        if (_data["defaultValues"]) {
            (<any>this).defaultValues = {} as any;
            for (let key in _data["defaultValues"]) {
                if (_data["defaultValues"].hasOwnProperty(key))
                    (<any>(<any>this).defaultValues)![key] = _data["defaultValues"][key];
            }
        }
        (<any>this).defaultValue = _data["defaultValue"];
        (<any>this).maxValue = _data["maxValue"];
        (<any>this).minValue = _data["minValue"];
        if (Array.isArray(_data["allowedValues"])) {
            (<any>this).allowedValues = [] as any;
            for (let item of _data["allowedValues"])
                (<any>this).allowedValues!.push(item);
        }
        (<any>this).isUnique = _data["isUnique"];
        (<any>this).inlineEditable = _data["inlineEditable"];
        (<any>this).editor = _data["editor"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): NumberFieldPropertiesDto {
        const result = new NumberFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this.defaultValues) {
            data["defaultValues"] = {};
            for (let key in this.defaultValues) {
                if (this.defaultValues.hasOwnProperty(key))
                    (<any>data["defaultValues"])[key] = (<any>this.defaultValues)[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        data["maxValue"] = this.maxValue;
        data["minValue"] = this.minValue;
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["isUnique"] = this.isUnique;
        data["inlineEditable"] = this.inlineEditable;
        data["editor"] = this.editor;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface INumberFieldPropertiesDto extends IFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: number; } | undefined;
    /** The default value for the field value. */
    readonly defaultValue?: number | undefined;
    /** The maximum allowed value for the field value. */
    readonly maxValue?: number | undefined;
    /** The minimum allowed value for the field value. */
    readonly minValue?: number | undefined;
    /** The allowed values for the field value. */
    readonly allowedValues?: number[] | undefined;
    /** Indicates if the field value must be unique. Ignored for nested fields and localized fields. */
    readonly isUnique?: boolean;
    /** Indicates that the inline editor is enabled for this field. */
    readonly inlineEditable?: boolean;
    /** The editor that is used to manage this field. */
    readonly editor?: NumberFieldEditor;
}

export type NumberFieldEditor = "Input" | "Radio" | "Dropdown" | "Stars";

export const NumberFieldEditorValues: ReadonlyArray<NumberFieldEditor> = [
	"Input",
	"Radio",
	"Dropdown",
	"Stars"
];

export class ReferencesFieldPropertiesDto extends FieldPropertiesDto implements IReferencesFieldPropertiesDto {
    /** The language specific default value as a list of content ids. */
    readonly defaultValues?: { [key: string]: string[]; } | undefined;
    /** The default value as a list of content ids. */
    readonly defaultValue?: string[] | undefined;
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** True, if duplicate values are allowed. */
    readonly allowDuplicates?: boolean;
    /** True to resolve references in the content list. */
    readonly resolveReference?: boolean;
    /** True when all references must be published. */
    readonly mustBePublished?: boolean;
    /** The initial query that is applied in the UI. */
    readonly query?: string | undefined;
    /** The editor that is used to manage this field. */
    readonly editor?: ReferencesFieldEditor;
    /** The ID of the referenced schemas. */
    readonly schemaIds?: string[] | undefined;

    public get singleId() {
        return this.schemaIds?.[0] || null;
    }

    public get isSortable() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitReferences(this);
    }

    constructor(data?: IReferencesFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "References";
    }

    init(_data: any) {
        super.init(_data);
        if (_data["defaultValues"]) {
            (<any>this).defaultValues = {} as any;
            for (let key in _data["defaultValues"]) {
                if (_data["defaultValues"].hasOwnProperty(key))
                    (<any>(<any>this).defaultValues)![key] = _data["defaultValues"][key] !== undefined ? _data["defaultValues"][key] : [];
            }
        }
        if (Array.isArray(_data["defaultValue"])) {
            (<any>this).defaultValue = [] as any;
            for (let item of _data["defaultValue"])
                (<any>this).defaultValue!.push(item);
        }
        (<any>this).minItems = _data["minItems"];
        (<any>this).maxItems = _data["maxItems"];
        (<any>this).allowDuplicates = _data["allowDuplicates"];
        (<any>this).resolveReference = _data["resolveReference"];
        (<any>this).mustBePublished = _data["mustBePublished"];
        (<any>this).query = _data["query"];
        (<any>this).editor = _data["editor"];
        if (Array.isArray(_data["schemaIds"])) {
            (<any>this).schemaIds = [] as any;
            for (let item of _data["schemaIds"])
                (<any>this).schemaIds!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ReferencesFieldPropertiesDto {
        const result = new ReferencesFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this.defaultValues) {
            data["defaultValues"] = {};
            for (let key in this.defaultValues) {
                if (this.defaultValues.hasOwnProperty(key))
                    (<any>data["defaultValues"])[key] = (<any>this.defaultValues)[key];
            }
        }
        if (Array.isArray(this.defaultValue)) {
            data["defaultValue"] = [];
            for (let item of this.defaultValue)
                data["defaultValue"].push(item);
        }
        data["minItems"] = this.minItems;
        data["maxItems"] = this.maxItems;
        data["allowDuplicates"] = this.allowDuplicates;
        data["resolveReference"] = this.resolveReference;
        data["mustBePublished"] = this.mustBePublished;
        data["query"] = this.query;
        data["editor"] = this.editor;
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IReferencesFieldPropertiesDto extends IFieldPropertiesDto {
    /** The language specific default value as a list of content ids. */
    readonly defaultValues?: { [key: string]: string[]; } | undefined;
    /** The default value as a list of content ids. */
    readonly defaultValue?: string[] | undefined;
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** True, if duplicate values are allowed. */
    readonly allowDuplicates?: boolean;
    /** True to resolve references in the content list. */
    readonly resolveReference?: boolean;
    /** True when all references must be published. */
    readonly mustBePublished?: boolean;
    /** The initial query that is applied in the UI. */
    readonly query?: string | undefined;
    /** The editor that is used to manage this field. */
    readonly editor?: ReferencesFieldEditor;
    /** The ID of the referenced schemas. */
    readonly schemaIds?: string[] | undefined;
}

export type ReferencesFieldEditor = "List" | "Dropdown" | "Tags" | "Checkboxes" | "Input" | "Radio";

export const ReferencesFieldEditorValues: ReadonlyArray<ReferencesFieldEditor> = [
	"List",
	"Dropdown",
	"Tags",
	"Checkboxes",
	"Input",
	"Radio"
];

export class RichTextFieldPropertiesDto extends FieldPropertiesDto implements IRichTextFieldPropertiesDto {
    /** The initial id to the folder when the control supports file uploads. */
    readonly folderId?: string | undefined;
    /** The minimum allowed length for the field value. */
    readonly minLength?: number | undefined;
    /** The maximum allowed length for the field value. */
    readonly maxLength?: number | undefined;
    /** The minimum allowed of normal characters for the field value. */
    readonly minCharacters?: number | undefined;
    /** The maximum allowed of normal characters for the field value. */
    readonly maxCharacters?: number | undefined;
    /** The minimum allowed number of words for the field value. */
    readonly minWords?: number | undefined;
    /** The maximum allowed number of words for the field value. */
    readonly maxWords?: number | undefined;
    /** The class names for the editor. */
    readonly classNames?: string[] | undefined;
    /** The allowed schema ids that can be embedded. */
    readonly schemaIds?: string[] | undefined;

    public get isSortable() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitRichText(this);
    }

    constructor(data?: IRichTextFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "RichText";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).folderId = _data["folderId"];
        (<any>this).minLength = _data["minLength"];
        (<any>this).maxLength = _data["maxLength"];
        (<any>this).minCharacters = _data["minCharacters"];
        (<any>this).maxCharacters = _data["maxCharacters"];
        (<any>this).minWords = _data["minWords"];
        (<any>this).maxWords = _data["maxWords"];
        if (Array.isArray(_data["classNames"])) {
            (<any>this).classNames = [] as any;
            for (let item of _data["classNames"])
                (<any>this).classNames!.push(item);
        }
        if (Array.isArray(_data["schemaIds"])) {
            (<any>this).schemaIds = [] as any;
            for (let item of _data["schemaIds"])
                (<any>this).schemaIds!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RichTextFieldPropertiesDto {
        const result = new RichTextFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["folderId"] = this.folderId;
        data["minLength"] = this.minLength;
        data["maxLength"] = this.maxLength;
        data["minCharacters"] = this.minCharacters;
        data["maxCharacters"] = this.maxCharacters;
        data["minWords"] = this.minWords;
        data["maxWords"] = this.maxWords;
        if (Array.isArray(this.classNames)) {
            data["classNames"] = [];
            for (let item of this.classNames)
                data["classNames"].push(item);
        }
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IRichTextFieldPropertiesDto extends IFieldPropertiesDto {
    /** The initial id to the folder when the control supports file uploads. */
    readonly folderId?: string | undefined;
    /** The minimum allowed length for the field value. */
    readonly minLength?: number | undefined;
    /** The maximum allowed length for the field value. */
    readonly maxLength?: number | undefined;
    /** The minimum allowed of normal characters for the field value. */
    readonly minCharacters?: number | undefined;
    /** The maximum allowed of normal characters for the field value. */
    readonly maxCharacters?: number | undefined;
    /** The minimum allowed number of words for the field value. */
    readonly minWords?: number | undefined;
    /** The maximum allowed number of words for the field value. */
    readonly maxWords?: number | undefined;
    /** The class names for the editor. */
    readonly classNames?: string[] | undefined;
    /** The allowed schema ids that can be embedded. */
    readonly schemaIds?: string[] | undefined;
}

export class StringFieldPropertiesDto extends FieldPropertiesDto implements IStringFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: string; } | undefined;
    /** The default value for the field value. */
    readonly defaultValue?: string | undefined;
    /** The pattern to enforce a specific format for the field value. */
    readonly pattern?: string | undefined;
    /** The validation message for the pattern. */
    readonly patternMessage?: string | undefined;
    /** The initial id to the folder when the control supports file uploads. */
    readonly folderId?: string | undefined;
    /** The minimum allowed length for the field value. */
    readonly minLength?: number | undefined;
    /** The maximum allowed length for the field value. */
    readonly maxLength?: number | undefined;
    /** The minimum allowed of normal characters for the field value. */
    readonly minCharacters?: number | undefined;
    /** The maximum allowed of normal characters for the field value. */
    readonly maxCharacters?: number | undefined;
    /** The minimum allowed number of words for the field value. */
    readonly minWords?: number | undefined;
    /** The maximum allowed number of words for the field value. */
    readonly maxWords?: number | undefined;
    /** The class names for the editor. */
    readonly classNames?: string[] | undefined;
    /** The allowed values for the field value. */
    readonly allowedValues?: string[] | undefined;
    /** The allowed schema ids that can be embedded. */
    readonly schemaIds?: string[] | undefined;
    /** Indicates if the field value must be unique. Ignored for nested fields and localized fields. */
    readonly isUnique?: boolean;
    /** Indicates that other content items or references are embedded. */
    readonly isEmbeddable?: boolean;
    /** Indicates that the inline editor is enabled for this field. */
    readonly inlineEditable?: boolean;
    /** Indicates whether GraphQL Enum should be created. */
    readonly createEnum?: boolean;
    /** How the string content should be interpreted. */
    readonly contentType?: StringContentType;
    /** The editor that is used to manage this field. */
    readonly editor?: StringFieldEditor;

    public get isComplexUI() {
        return this.editor !== 'Input' && this.editor !== 'Color' && this.editor !== 'Radio' && this.editor !== 'Slug' && this.editor !== 'TextArea';
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitString(this);
    }

    constructor(data?: IStringFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "String";
    }

    init(_data: any) {
        super.init(_data);
        if (_data["defaultValues"]) {
            (<any>this).defaultValues = {} as any;
            for (let key in _data["defaultValues"]) {
                if (_data["defaultValues"].hasOwnProperty(key))
                    (<any>(<any>this).defaultValues)![key] = _data["defaultValues"][key];
            }
        }
        (<any>this).defaultValue = _data["defaultValue"];
        (<any>this).pattern = _data["pattern"];
        (<any>this).patternMessage = _data["patternMessage"];
        (<any>this).folderId = _data["folderId"];
        (<any>this).minLength = _data["minLength"];
        (<any>this).maxLength = _data["maxLength"];
        (<any>this).minCharacters = _data["minCharacters"];
        (<any>this).maxCharacters = _data["maxCharacters"];
        (<any>this).minWords = _data["minWords"];
        (<any>this).maxWords = _data["maxWords"];
        if (Array.isArray(_data["classNames"])) {
            (<any>this).classNames = [] as any;
            for (let item of _data["classNames"])
                (<any>this).classNames!.push(item);
        }
        if (Array.isArray(_data["allowedValues"])) {
            (<any>this).allowedValues = [] as any;
            for (let item of _data["allowedValues"])
                (<any>this).allowedValues!.push(item);
        }
        if (Array.isArray(_data["schemaIds"])) {
            (<any>this).schemaIds = [] as any;
            for (let item of _data["schemaIds"])
                (<any>this).schemaIds!.push(item);
        }
        (<any>this).isUnique = _data["isUnique"];
        (<any>this).isEmbeddable = _data["isEmbeddable"];
        (<any>this).inlineEditable = _data["inlineEditable"];
        (<any>this).createEnum = _data["createEnum"];
        (<any>this).contentType = _data["contentType"];
        (<any>this).editor = _data["editor"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): StringFieldPropertiesDto {
        const result = new StringFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this.defaultValues) {
            data["defaultValues"] = {};
            for (let key in this.defaultValues) {
                if (this.defaultValues.hasOwnProperty(key))
                    (<any>data["defaultValues"])[key] = (<any>this.defaultValues)[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        data["pattern"] = this.pattern;
        data["patternMessage"] = this.patternMessage;
        data["folderId"] = this.folderId;
        data["minLength"] = this.minLength;
        data["maxLength"] = this.maxLength;
        data["minCharacters"] = this.minCharacters;
        data["maxCharacters"] = this.maxCharacters;
        data["minWords"] = this.minWords;
        data["maxWords"] = this.maxWords;
        if (Array.isArray(this.classNames)) {
            data["classNames"] = [];
            for (let item of this.classNames)
                data["classNames"].push(item);
        }
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["isUnique"] = this.isUnique;
        data["isEmbeddable"] = this.isEmbeddable;
        data["inlineEditable"] = this.inlineEditable;
        data["createEnum"] = this.createEnum;
        data["contentType"] = this.contentType;
        data["editor"] = this.editor;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IStringFieldPropertiesDto extends IFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: string; } | undefined;
    /** The default value for the field value. */
    readonly defaultValue?: string | undefined;
    /** The pattern to enforce a specific format for the field value. */
    readonly pattern?: string | undefined;
    /** The validation message for the pattern. */
    readonly patternMessage?: string | undefined;
    /** The initial id to the folder when the control supports file uploads. */
    readonly folderId?: string | undefined;
    /** The minimum allowed length for the field value. */
    readonly minLength?: number | undefined;
    /** The maximum allowed length for the field value. */
    readonly maxLength?: number | undefined;
    /** The minimum allowed of normal characters for the field value. */
    readonly minCharacters?: number | undefined;
    /** The maximum allowed of normal characters for the field value. */
    readonly maxCharacters?: number | undefined;
    /** The minimum allowed number of words for the field value. */
    readonly minWords?: number | undefined;
    /** The maximum allowed number of words for the field value. */
    readonly maxWords?: number | undefined;
    /** The class names for the editor. */
    readonly classNames?: string[] | undefined;
    /** The allowed values for the field value. */
    readonly allowedValues?: string[] | undefined;
    /** The allowed schema ids that can be embedded. */
    readonly schemaIds?: string[] | undefined;
    /** Indicates if the field value must be unique. Ignored for nested fields and localized fields. */
    readonly isUnique?: boolean;
    /** Indicates that other content items or references are embedded. */
    readonly isEmbeddable?: boolean;
    /** Indicates that the inline editor is enabled for this field. */
    readonly inlineEditable?: boolean;
    /** Indicates whether GraphQL Enum should be created. */
    readonly createEnum?: boolean;
    /** How the string content should be interpreted. */
    readonly contentType?: StringContentType;
    /** The editor that is used to manage this field. */
    readonly editor?: StringFieldEditor;
}

export type StringContentType = "Unspecified" | "Html" | "Markdown";

export const StringContentTypeValues: ReadonlyArray<StringContentType> = [
	"Unspecified",
	"Html",
	"Markdown"
];

export type StringFieldEditor = "Input" | "Color" | "Markdown" | "Dropdown" | "Html" | "Radio" | "RichText" | "Slug" | "StockPhoto" | "TextArea";

export const StringFieldEditorValues: ReadonlyArray<StringFieldEditor> = [
	"Input",
	"Color",
	"Markdown",
	"Dropdown",
	"Html",
	"Radio",
	"RichText",
	"Slug",
	"StockPhoto",
	"TextArea"
];

export class TagsFieldPropertiesDto extends FieldPropertiesDto implements ITagsFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: string[]; } | undefined;
    /** The default value. */
    readonly defaultValue?: string[] | undefined;
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** The allowed values for the field value. */
    readonly allowedValues?: string[] | undefined;
    /** Indicates whether GraphQL Enum should be created. */
    readonly createEnum?: boolean;
    /** The editor that is used to manage this field. */
    readonly editor?: TagsFieldEditor;

    public get isComplexUI() {
        return false;
    }

    public get isSortable() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitTags(this);
    }

    constructor(data?: ITagsFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "Tags";
    }

    init(_data: any) {
        super.init(_data);
        if (_data["defaultValues"]) {
            (<any>this).defaultValues = {} as any;
            for (let key in _data["defaultValues"]) {
                if (_data["defaultValues"].hasOwnProperty(key))
                    (<any>(<any>this).defaultValues)![key] = _data["defaultValues"][key] !== undefined ? _data["defaultValues"][key] : [];
            }
        }
        if (Array.isArray(_data["defaultValue"])) {
            (<any>this).defaultValue = [] as any;
            for (let item of _data["defaultValue"])
                (<any>this).defaultValue!.push(item);
        }
        (<any>this).minItems = _data["minItems"];
        (<any>this).maxItems = _data["maxItems"];
        if (Array.isArray(_data["allowedValues"])) {
            (<any>this).allowedValues = [] as any;
            for (let item of _data["allowedValues"])
                (<any>this).allowedValues!.push(item);
        }
        (<any>this).createEnum = _data["createEnum"];
        (<any>this).editor = _data["editor"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TagsFieldPropertiesDto {
        const result = new TagsFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this.defaultValues) {
            data["defaultValues"] = {};
            for (let key in this.defaultValues) {
                if (this.defaultValues.hasOwnProperty(key))
                    (<any>data["defaultValues"])[key] = (<any>this.defaultValues)[key];
            }
        }
        if (Array.isArray(this.defaultValue)) {
            data["defaultValue"] = [];
            for (let item of this.defaultValue)
                data["defaultValue"].push(item);
        }
        data["minItems"] = this.minItems;
        data["maxItems"] = this.maxItems;
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["createEnum"] = this.createEnum;
        data["editor"] = this.editor;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ITagsFieldPropertiesDto extends IFieldPropertiesDto {
    /** The language specific default value for the field value. */
    readonly defaultValues?: { [key: string]: string[]; } | undefined;
    /** The default value. */
    readonly defaultValue?: string[] | undefined;
    /** The minimum allowed items for the field value. */
    readonly minItems?: number | undefined;
    /** The maximum allowed items for the field value. */
    readonly maxItems?: number | undefined;
    /** The allowed values for the field value. */
    readonly allowedValues?: string[] | undefined;
    /** Indicates whether GraphQL Enum should be created. */
    readonly createEnum?: boolean;
    /** The editor that is used to manage this field. */
    readonly editor?: TagsFieldEditor;
}

export type TagsFieldEditor = "Tags" | "Checkboxes" | "Dropdown";

export const TagsFieldEditorValues: ReadonlyArray<TagsFieldEditor> = [
	"Tags",
	"Checkboxes",
	"Dropdown"
];

export class UIFieldPropertiesDto extends FieldPropertiesDto implements IUIFieldPropertiesDto {
    /** The editor that is used to manage this field. */
    readonly editor?: UIFieldEditor;

    public get isComplexUI() {
        return false;
    }

    public get isSortable() {
        return false;
    }

    public get isContentField() {
        return false;
    }

    public accept<T>(visitor: FieldPropertiesVisitor<T>): T {
        return visitor.visitUI(this);
    }

    constructor(data?: IUIFieldPropertiesDto) {
        super(data);
        (<any>this).fieldType = "UI";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).editor = _data["editor"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UIFieldPropertiesDto {
        const result = new UIFieldPropertiesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["editor"] = this.editor;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IUIFieldPropertiesDto extends IFieldPropertiesDto {
    /** The editor that is used to manage this field. */
    readonly editor?: UIFieldEditor;
}

export type UIFieldEditor = "Separator";

export const UIFieldEditorValues: ReadonlyArray<UIFieldEditor> = [
	"Separator"
];

export class NestedFieldDto extends ResourceDto implements INestedFieldDto {
    /** The ID of the field. */
    readonly fieldId!: number;
    /** The name of the field. Must be unique within the schema. */
    readonly name!: string;
    /** Defines if the field is hidden. */
    readonly isHidden!: boolean;
    /** Defines if the field is locked. */
    readonly isLocked!: boolean;
    /** Defines if the field is disabled. */
    readonly isDisabled!: boolean;
    /** The field properties. */
    readonly properties!: FieldPropertiesDto;

    public get rawProperties(): any {
        return this.properties;
    }

    public get displayName() {
        return this.compute('displayName', () => StringHelper.firstNonEmpty(this.properties.label, this.name));
    }

    public get displayPlaceholder() {
        return this.compute('displayPlaceholder', () => this.properties.placeholder || '');
    }

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canDisable() {
        return this.compute('canDisable', () => hasAnyLink(this._links, 'disable'));
    }

    get canEnable() {
        return this.compute('canEnable', () => hasAnyLink(this._links, 'enable'));
    }
    get canHide() {
        return this.compute('canHide', () => hasAnyLink(this._links, 'hide'));
    }

    get canLock() {
        return this.compute('canLock', () => hasAnyLink(this._links, 'lock'));
    }

    get canShow() {
        return this.compute('canShow', () => hasAnyLink(this._links, 'show'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: INestedFieldDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).fieldId = _data["fieldId"];
        (<any>this).name = _data["name"];
        (<any>this).isHidden = _data["isHidden"];
        (<any>this).isLocked = _data["isLocked"];
        (<any>this).isDisabled = _data["isDisabled"];
        (<any>this).properties = _data["properties"] ? FieldPropertiesDto.fromJSON(_data["properties"]) : <any>undefined;
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): NestedFieldDto {
        const result = new NestedFieldDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["fieldId"] = this.fieldId;
        data["name"] = this.name;
        data["isHidden"] = this.isHidden;
        data["isLocked"] = this.isLocked;
        data["isDisabled"] = this.isDisabled;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface INestedFieldDto extends IResourceDto {
    /** The ID of the field. */
    readonly fieldId: number;
    /** The name of the field. Must be unique within the schema. */
    readonly name: string;
    /** Defines if the field is hidden. */
    readonly isHidden: boolean;
    /** Defines if the field is locked. */
    readonly isLocked: boolean;
    /** Defines if the field is disabled. */
    readonly isDisabled: boolean;
    /** The field properties. */
    readonly properties: FieldPropertiesDto;
}

export class AddFieldDto implements IAddFieldDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the field. Must be unique within the schema. */
    readonly name!: string;
    /** Determines the optional partitioning of the field. */
    readonly partitioning?: string | undefined;
    /** The field properties. */
    readonly properties!: FieldPropertiesDto;

    constructor(data?: IAddFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).partitioning = _data["partitioning"];
        (<any>this).properties = _data["properties"] ? FieldPropertiesDto.fromJSON(_data["properties"]) : <any>undefined;
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AddFieldDto {
        const result = new AddFieldDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["partitioning"] = this.partitioning;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAddFieldDto {
    /** The name of the field. Must be unique within the schema. */
    readonly name: string;
    /** Determines the optional partitioning of the field. */
    readonly partitioning?: string | undefined;
    /** The field properties. */
    readonly properties: FieldPropertiesDto;
}

export class ConfigureUIFieldsDto implements IConfigureUIFieldsDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of fields that are used in content lists. */
    readonly fieldsInLists?: string[] | undefined;
    /** The name of fields that are used in content references. */
    readonly fieldsInReferences?: string[] | undefined;

    constructor(data?: IConfigureUIFieldsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["fieldsInLists"])) {
            (<any>this).fieldsInLists = [] as any;
            for (let item of _data["fieldsInLists"])
                (<any>this).fieldsInLists!.push(item);
        }
        if (Array.isArray(_data["fieldsInReferences"])) {
            (<any>this).fieldsInReferences = [] as any;
            for (let item of _data["fieldsInReferences"])
                (<any>this).fieldsInReferences!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ConfigureUIFieldsDto {
        const result = new ConfigureUIFieldsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.fieldsInLists)) {
            data["fieldsInLists"] = [];
            for (let item of this.fieldsInLists)
                data["fieldsInLists"].push(item);
        }
        if (Array.isArray(this.fieldsInReferences)) {
            data["fieldsInReferences"] = [];
            for (let item of this.fieldsInReferences)
                data["fieldsInReferences"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IConfigureUIFieldsDto {
    /** The name of fields that are used in content lists. */
    readonly fieldsInLists?: string[] | undefined;
    /** The name of fields that are used in content references. */
    readonly fieldsInReferences?: string[] | undefined;
}

export class ReorderFieldsDto implements IReorderFieldsDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The field ids in the target order. */
    readonly fieldIds!: number[];

    constructor(data?: IReorderFieldsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["fieldIds"])) {
            (<any>this).fieldIds = [] as any;
            for (let item of _data["fieldIds"])
                (<any>this).fieldIds!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ReorderFieldsDto {
        const result = new ReorderFieldsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.fieldIds)) {
            data["fieldIds"] = [];
            for (let item of this.fieldIds)
                data["fieldIds"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IReorderFieldsDto {
    /** The field ids in the target order. */
    readonly fieldIds: number[];
}

export class UpdateFieldDto implements IUpdateFieldDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The field properties. */
    readonly properties!: FieldPropertiesDto;

    constructor(data?: IUpdateFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).properties = _data["properties"] ? FieldPropertiesDto.fromJSON(_data["properties"]) : <any>undefined;
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateFieldDto {
        const result = new UpdateFieldDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateFieldDto {
    /** The field properties. */
    readonly properties: FieldPropertiesDto;
}

export class IndexesDto extends ResourceDto implements IIndexesDto {
    /** The indexes. */
    readonly items!: IndexDto[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    constructor(data?: IIndexesDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(IndexDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): IndexesDto {
        const result = new IndexesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IIndexesDto extends IResourceDto {
    /** The indexes. */
    readonly items: IndexDto[];
}

export class IndexDto extends ResourceDto implements IIndexDto {
    /** The name of the index. */
    readonly name!: string;
    /** The index fields. */
    readonly fields!: IndexFieldDto[];

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    constructor(data?: IIndexDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).name = _data["name"];
        if (Array.isArray(_data["fields"])) {
            (<any>this).fields = [] as any;
            for (let item of _data["fields"])
                (<any>this).fields!.push(IndexFieldDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): IndexDto {
        const result = new IndexDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IIndexDto extends IResourceDto {
    /** The name of the index. */
    readonly name: string;
    /** The index fields. */
    readonly fields: IndexFieldDto[];
}

export class IndexFieldDto implements IIndexFieldDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the field. */
    readonly name!: string;
    /** The sort order of the field. */
    readonly order!: SortOrder;

    constructor(data?: IIndexFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).order = _data["order"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): IndexFieldDto {
        const result = new IndexFieldDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["order"] = this.order;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IIndexFieldDto {
    /** The name of the field. */
    readonly name: string;
    /** The sort order of the field. */
    readonly order: SortOrder;
}

export type SortOrder = "Ascending" | "Descending";

export const SortOrderValues: ReadonlyArray<SortOrder> = [
	"Ascending",
	"Descending"
];

export class CreateIndexDto implements ICreateIndexDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The index fields. */
    readonly fields!: IndexFieldDto[];

    constructor(data?: ICreateIndexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["fields"])) {
            (<any>this).fields = [] as any;
            for (let item of _data["fields"])
                (<any>this).fields!.push(IndexFieldDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateIndexDto {
        const result = new CreateIndexDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICreateIndexDto {
    /** The index fields. */
    readonly fields: IndexFieldDto[];
}

export class SchemasDto extends ResourceDto implements ISchemasDto {
    /** The schemas. */
    readonly items!: SchemaDto[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    constructor(data?: ISchemasDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(SchemaDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SchemasDto {
        const result = new SchemasDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISchemasDto extends IResourceDto {
    /** The schemas. */
    readonly items: SchemaDto[];
}

export abstract class UpsertSchemaDto implements IUpsertSchemaDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The optional properties. */
    readonly properties?: SchemaPropertiesDto | undefined;
    /** The optional scripts. */
    readonly scripts?: SchemaScriptsDto | undefined;
    /** The names of the fields that should be used in references. */
    readonly fieldsInReferences?: string[] | undefined;
    /** The names of the fields that should be shown in lists, including meta fields. */
    readonly fieldsInLists?: string[] | undefined;
    /** Optional fields. */
    readonly fields?: UpsertSchemaFieldDto[] | undefined;
    /** The optional preview urls. */
    readonly previewUrls?: { [key: string]: string; } | undefined;
    /** The optional field Rules. */
    readonly fieldRules?: FieldRuleDto[] | undefined;
    /** The category. */
    readonly category?: string | undefined;
    /** Set it to true to autopublish the schema. */
    readonly isPublished?: boolean;

    constructor(data?: IUpsertSchemaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).properties = _data["properties"] ? SchemaPropertiesDto.fromJSON(_data["properties"]) : <any>undefined;
        (<any>this).scripts = _data["scripts"] ? SchemaScriptsDto.fromJSON(_data["scripts"]) : <any>undefined;
        if (Array.isArray(_data["fieldsInReferences"])) {
            (<any>this).fieldsInReferences = [] as any;
            for (let item of _data["fieldsInReferences"])
                (<any>this).fieldsInReferences!.push(item);
        }
        if (Array.isArray(_data["fieldsInLists"])) {
            (<any>this).fieldsInLists = [] as any;
            for (let item of _data["fieldsInLists"])
                (<any>this).fieldsInLists!.push(item);
        }
        if (Array.isArray(_data["fields"])) {
            (<any>this).fields = [] as any;
            for (let item of _data["fields"])
                (<any>this).fields!.push(UpsertSchemaFieldDto.fromJSON(item));
        }
        if (_data["previewUrls"]) {
            (<any>this).previewUrls = {} as any;
            for (let key in _data["previewUrls"]) {
                if (_data["previewUrls"].hasOwnProperty(key))
                    (<any>(<any>this).previewUrls)![key] = _data["previewUrls"][key];
            }
        }
        if (Array.isArray(_data["fieldRules"])) {
            (<any>this).fieldRules = [] as any;
            for (let item of _data["fieldRules"])
                (<any>this).fieldRules!.push(FieldRuleDto.fromJSON(item));
        }
        (<any>this).category = _data["category"];
        (<any>this).isPublished = _data["isPublished"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpsertSchemaDto {
        throw new Error("The abstract class 'UpsertSchemaDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["scripts"] = this.scripts ? this.scripts.toJSON() : <any>undefined;
        if (Array.isArray(this.fieldsInReferences)) {
            data["fieldsInReferences"] = [];
            for (let item of this.fieldsInReferences)
                data["fieldsInReferences"].push(item);
        }
        if (Array.isArray(this.fieldsInLists)) {
            data["fieldsInLists"] = [];
            for (let item of this.fieldsInLists)
                data["fieldsInLists"].push(item);
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.previewUrls) {
            data["previewUrls"] = {};
            for (let key in this.previewUrls) {
                if (this.previewUrls.hasOwnProperty(key))
                    (<any>data["previewUrls"])[key] = (<any>this.previewUrls)[key];
            }
        }
        if (Array.isArray(this.fieldRules)) {
            data["fieldRules"] = [];
            for (let item of this.fieldRules)
                data["fieldRules"].push(item.toJSON());
        }
        data["category"] = this.category;
        data["isPublished"] = this.isPublished;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpsertSchemaDto {
    /** The optional properties. */
    readonly properties?: SchemaPropertiesDto | undefined;
    /** The optional scripts. */
    readonly scripts?: SchemaScriptsDto | undefined;
    /** The names of the fields that should be used in references. */
    readonly fieldsInReferences?: string[] | undefined;
    /** The names of the fields that should be shown in lists, including meta fields. */
    readonly fieldsInLists?: string[] | undefined;
    /** Optional fields. */
    readonly fields?: UpsertSchemaFieldDto[] | undefined;
    /** The optional preview urls. */
    readonly previewUrls?: { [key: string]: string; } | undefined;
    /** The optional field Rules. */
    readonly fieldRules?: FieldRuleDto[] | undefined;
    /** The category. */
    readonly category?: string | undefined;
    /** Set it to true to autopublish the schema. */
    readonly isPublished?: boolean;
}

export class CreateSchemaDto extends UpsertSchemaDto implements ICreateSchemaDto {
    /** The name of the schema. */
    readonly name!: string;
    /** The type of the schema. */
    readonly type?: SchemaType;
    /** Set to true to allow a single content item only. */
    readonly isSingleton?: boolean;

    constructor(data?: ICreateSchemaDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).name = _data["name"];
        (<any>this).type = _data["type"];
        (<any>this).isSingleton = _data["isSingleton"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateSchemaDto {
        const result = new CreateSchemaDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["type"] = this.type;
        data["isSingleton"] = this.isSingleton;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ICreateSchemaDto extends IUpsertSchemaDto {
    /** The name of the schema. */
    readonly name: string;
    /** The type of the schema. */
    readonly type?: SchemaType;
    /** Set to true to allow a single content item only. */
    readonly isSingleton?: boolean;
}

export class UpsertSchemaFieldDto implements IUpsertSchemaFieldDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the field. Must be unique within the schema. */
    readonly name!: string;
    /** Defines if the field is hidden. */
    readonly isHidden?: boolean;
    /** Defines if the field is locked. */
    readonly isLocked?: boolean;
    /** Defines if the field is disabled. */
    readonly isDisabled?: boolean;
    /** Determines the optional partitioning of the field. */
    readonly partitioning?: string | undefined;
    /** The field properties. */
    readonly properties!: FieldPropertiesDto;
    /** The nested fields. */
    readonly nested?: UpsertSchemaNestedFieldDto[] | undefined;

    constructor(data?: IUpsertSchemaFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).isHidden = _data["isHidden"];
        (<any>this).isLocked = _data["isLocked"];
        (<any>this).isDisabled = _data["isDisabled"];
        (<any>this).partitioning = _data["partitioning"];
        (<any>this).properties = _data["properties"] ? FieldPropertiesDto.fromJSON(_data["properties"]) : <any>undefined;
        if (Array.isArray(_data["nested"])) {
            (<any>this).nested = [] as any;
            for (let item of _data["nested"])
                (<any>this).nested!.push(UpsertSchemaNestedFieldDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpsertSchemaFieldDto {
        const result = new UpsertSchemaFieldDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["isHidden"] = this.isHidden;
        data["isLocked"] = this.isLocked;
        data["isDisabled"] = this.isDisabled;
        data["partitioning"] = this.partitioning;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        if (Array.isArray(this.nested)) {
            data["nested"] = [];
            for (let item of this.nested)
                data["nested"].push(item.toJSON());
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpsertSchemaFieldDto {
    /** The name of the field. Must be unique within the schema. */
    readonly name: string;
    /** Defines if the field is hidden. */
    readonly isHidden?: boolean;
    /** Defines if the field is locked. */
    readonly isLocked?: boolean;
    /** Defines if the field is disabled. */
    readonly isDisabled?: boolean;
    /** Determines the optional partitioning of the field. */
    readonly partitioning?: string | undefined;
    /** The field properties. */
    readonly properties: FieldPropertiesDto;
    /** The nested fields. */
    readonly nested?: UpsertSchemaNestedFieldDto[] | undefined;
}

export class UpsertSchemaNestedFieldDto implements IUpsertSchemaNestedFieldDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the field. Must be unique within the schema. */
    readonly name!: string;
    /** Defines if the field is hidden. */
    readonly isHidden?: boolean;
    /** Defines if the field is locked. */
    readonly isLocked?: boolean;
    /** Defines if the field is disabled. */
    readonly isDisabled?: boolean;
    /** The field properties. */
    readonly properties!: FieldPropertiesDto;

    constructor(data?: IUpsertSchemaNestedFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).isHidden = _data["isHidden"];
        (<any>this).isLocked = _data["isLocked"];
        (<any>this).isDisabled = _data["isDisabled"];
        (<any>this).properties = _data["properties"] ? FieldPropertiesDto.fromJSON(_data["properties"]) : <any>undefined;
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpsertSchemaNestedFieldDto {
        const result = new UpsertSchemaNestedFieldDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["isHidden"] = this.isHidden;
        data["isLocked"] = this.isLocked;
        data["isDisabled"] = this.isDisabled;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpsertSchemaNestedFieldDto {
    /** The name of the field. Must be unique within the schema. */
    readonly name: string;
    /** Defines if the field is hidden. */
    readonly isHidden?: boolean;
    /** Defines if the field is locked. */
    readonly isLocked?: boolean;
    /** Defines if the field is disabled. */
    readonly isDisabled?: boolean;
    /** The field properties. */
    readonly properties: FieldPropertiesDto;
}

export class UpdateSchemaDto implements IUpdateSchemaDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Optional label for the editor. */
    readonly label?: string | undefined;
    /** Hints to describe the schema. */
    readonly hints?: string | undefined;
    /** The url to a the sidebar plugin for content lists. */
    readonly contentsSidebarUrl?: string | undefined;
    /** The url to a the sidebar plugin for content items. */
    readonly contentSidebarUrl?: string | undefined;
    /** The url to the content list plugin. */
    readonly contentsListUrl?: string | undefined;
    /** True to validate the content items on publish. */
    readonly validateOnPublish?: boolean;
    /** Tags for automation processes. */
    readonly tags?: string[] | undefined;

    constructor(data?: IUpdateSchemaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).label = _data["label"];
        (<any>this).hints = _data["hints"];
        (<any>this).contentsSidebarUrl = _data["contentsSidebarUrl"];
        (<any>this).contentSidebarUrl = _data["contentSidebarUrl"];
        (<any>this).contentsListUrl = _data["contentsListUrl"];
        (<any>this).validateOnPublish = _data["validateOnPublish"];
        if (Array.isArray(_data["tags"])) {
            (<any>this).tags = [] as any;
            for (let item of _data["tags"])
                (<any>this).tags!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateSchemaDto {
        const result = new UpdateSchemaDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["label"] = this.label;
        data["hints"] = this.hints;
        data["contentsSidebarUrl"] = this.contentsSidebarUrl;
        data["contentSidebarUrl"] = this.contentSidebarUrl;
        data["contentsListUrl"] = this.contentsListUrl;
        data["validateOnPublish"] = this.validateOnPublish;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateSchemaDto {
    /** Optional label for the editor. */
    readonly label?: string | undefined;
    /** Hints to describe the schema. */
    readonly hints?: string | undefined;
    /** The url to a the sidebar plugin for content lists. */
    readonly contentsSidebarUrl?: string | undefined;
    /** The url to a the sidebar plugin for content items. */
    readonly contentSidebarUrl?: string | undefined;
    /** The url to the content list plugin. */
    readonly contentsListUrl?: string | undefined;
    /** True to validate the content items on publish. */
    readonly validateOnPublish?: boolean;
    /** Tags for automation processes. */
    readonly tags?: string[] | undefined;
}

export class SynchronizeSchemaDto extends UpsertSchemaDto implements ISynchronizeSchemaDto {
    /** True, when fields should not be deleted. */
    readonly noFieldDeletion?: boolean;
    /** True, when fields with different types should not be recreated. */
    readonly noFieldRecreation?: boolean;

    constructor(data?: ISynchronizeSchemaDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).noFieldDeletion = _data["noFieldDeletion"];
        (<any>this).noFieldRecreation = _data["noFieldRecreation"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SynchronizeSchemaDto {
        const result = new SynchronizeSchemaDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["noFieldDeletion"] = this.noFieldDeletion;
        data["noFieldRecreation"] = this.noFieldRecreation;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISynchronizeSchemaDto extends IUpsertSchemaDto {
    /** True, when fields should not be deleted. */
    readonly noFieldDeletion?: boolean;
    /** True, when fields with different types should not be recreated. */
    readonly noFieldRecreation?: boolean;
}

export class ChangeCategoryDto implements IChangeCategoryDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the category. */
    readonly name?: string | undefined;

    constructor(data?: IChangeCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ChangeCategoryDto {
        const result = new ChangeCategoryDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IChangeCategoryDto {
    /** The name of the category. */
    readonly name?: string | undefined;
}

export class ConfigureFieldRulesDto implements IConfigureFieldRulesDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The field rules to configure. */
    readonly fieldRules?: FieldRuleDto[] | undefined;

    constructor(data?: IConfigureFieldRulesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["fieldRules"])) {
            (<any>this).fieldRules = [] as any;
            for (let item of _data["fieldRules"])
                (<any>this).fieldRules!.push(FieldRuleDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ConfigureFieldRulesDto {
        const result = new ConfigureFieldRulesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.fieldRules)) {
            data["fieldRules"] = [];
            for (let item of this.fieldRules)
                data["fieldRules"].push(item.toJSON());
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IConfigureFieldRulesDto {
    /** The field rules to configure. */
    readonly fieldRules?: FieldRuleDto[] | undefined;
}

export class RuleElementDto implements IRuleElementDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Describes the action or trigger type. */
    readonly description!: string;
    /** The label for the action or trigger type. */
    readonly display!: string;
    /** Optional title. */
    readonly title?: string | undefined;
    /** The color for the icon. */
    readonly iconColor?: string | undefined;
    /** The image for the icon. */
    readonly iconImage?: string | undefined;
    /** The optional link to the product that is integrated. */
    readonly readMore?: string | undefined;
    /** The properties. */
    readonly properties!: RuleElementPropertyDto[];

    constructor(data?: IRuleElementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).description = _data["description"];
        (<any>this).display = _data["display"];
        (<any>this).title = _data["title"];
        (<any>this).iconColor = _data["iconColor"];
        (<any>this).iconImage = _data["iconImage"];
        (<any>this).readMore = _data["readMore"];
        if (Array.isArray(_data["properties"])) {
            (<any>this).properties = [] as any;
            for (let item of _data["properties"])
                (<any>this).properties!.push(RuleElementPropertyDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RuleElementDto {
        const result = new RuleElementDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["description"] = this.description;
        data["display"] = this.display;
        data["title"] = this.title;
        data["iconColor"] = this.iconColor;
        data["iconImage"] = this.iconImage;
        data["readMore"] = this.readMore;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IRuleElementDto {
    /** Describes the action or trigger type. */
    readonly description: string;
    /** The label for the action or trigger type. */
    readonly display: string;
    /** Optional title. */
    readonly title?: string | undefined;
    /** The color for the icon. */
    readonly iconColor?: string | undefined;
    /** The image for the icon. */
    readonly iconImage?: string | undefined;
    /** The optional link to the product that is integrated. */
    readonly readMore?: string | undefined;
    /** The properties. */
    readonly properties: RuleElementPropertyDto[];
}

export class RuleElementPropertyDto implements IRuleElementPropertyDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The html editor. */
    readonly editor!: string;
    /** The name of the editor. */
    readonly name!: string;
    /** The label to use. */
    readonly display!: string;
    /** The options, if the editor is a dropdown. */
    readonly options?: string[] | undefined;
    /** The optional description. */
    readonly description?: string | undefined;
    /** Indicates if the property is formattable. */
    readonly isFormattable!: boolean;
    /** Indicates if the property is required. */
    readonly isRequired!: boolean;

    constructor(data?: IRuleElementPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).editor = _data["editor"];
        (<any>this).name = _data["name"];
        (<any>this).display = _data["display"];
        if (Array.isArray(_data["options"])) {
            (<any>this).options = [] as any;
            for (let item of _data["options"])
                (<any>this).options!.push(item);
        }
        (<any>this).description = _data["description"];
        (<any>this).isFormattable = _data["isFormattable"];
        (<any>this).isRequired = _data["isRequired"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RuleElementPropertyDto {
        const result = new RuleElementPropertyDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["editor"] = this.editor;
        data["name"] = this.name;
        data["display"] = this.display;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        data["description"] = this.description;
        data["isFormattable"] = this.isFormattable;
        data["isRequired"] = this.isRequired;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IRuleElementPropertyDto {
    /** The html editor. */
    readonly editor: string;
    /** The name of the editor. */
    readonly name: string;
    /** The label to use. */
    readonly display: string;
    /** The options, if the editor is a dropdown. */
    readonly options?: string[] | undefined;
    /** The optional description. */
    readonly description?: string | undefined;
    /** Indicates if the property is formattable. */
    readonly isFormattable: boolean;
    /** Indicates if the property is required. */
    readonly isRequired: boolean;
}

export class RulesDto extends ResourceDto implements IRulesDto {
    /** The rules. */
    readonly items!: RuleDto[];
    /** The ID of the rule that is currently rerunning. */
    readonly runningRuleId?: string | undefined;

    constructor(data?: IRulesDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(RuleDto.fromJSON(item));
        }
        (<any>this).runningRuleId = _data["runningRuleId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RulesDto {
        const result = new RulesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["runningRuleId"] = this.runningRuleId;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IRulesDto extends IResourceDto {
    /** The rules. */
    readonly items: RuleDto[];
    /** The ID of the rule that is currently rerunning. */
    readonly runningRuleId?: string | undefined;
}

export class RuleDto extends ResourceDto implements IRuleDto {
    /** The ID of the rule. */
    readonly id!: string;
    /** The user that has created the rule. */
    readonly createdBy!: string;
    /** The user that has updated the rule. */
    readonly lastModifiedBy!: string;
    /** The date and time when the rule has been created. */
    readonly created!: DateTime;
    /** The date and time when the rule has been modified last. */
    readonly lastModified!: DateTime;
    /** The version of the rule. */
    readonly version!: number;
    /** Determines if the rule is enabled. */
    readonly isEnabled!: boolean;
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger!: RuleTriggerDto;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow!: FlowDefinitionDto;
    /** The action properties. */
    readonly action!: RuleActionDto;
    /** The number of completed executions. */
    readonly numSucceeded!: number;
    /** The number of failed executions. */
    readonly numFailed!: number;
    /** The date and time when the rule was executed the last time. */
    readonly lastExecuted?: DateTime | undefined;

    constructor(data?: IRuleDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).createdBy = _data["createdBy"];
        (<any>this).lastModifiedBy = _data["lastModifiedBy"];
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).lastModified = _data["lastModified"] ? DateTime.parseISO(_data["lastModified"].toString()) : <any>undefined;
        (<any>this).version = _data["version"];
        (<any>this).isEnabled = _data["isEnabled"];
        (<any>this).name = _data["name"];
        (<any>this).trigger = _data["trigger"] ? RuleTriggerDto.fromJSON(_data["trigger"]) : <any>undefined;
        (<any>this).flow = _data["flow"] ? FlowDefinitionDto.fromJSON(_data["flow"]) : new FlowDefinitionDto();
        (<any>this).action = _data["action"] ? RuleActionDto.fromJSON(_data["action"]) : <any>undefined;
        (<any>this).numSucceeded = _data["numSucceeded"];
        (<any>this).numFailed = _data["numFailed"];
        (<any>this).lastExecuted = _data["lastExecuted"] ? DateTime.parseISO(_data["lastExecuted"].toString()) : <any>undefined;
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RuleDto {
        const result = new RuleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["isEnabled"] = this.isEnabled;
        data["name"] = this.name;
        data["trigger"] = this.trigger ? this.trigger.toJSON() : <any>undefined;
        data["flow"] = this.flow ? this.flow.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["numSucceeded"] = this.numSucceeded;
        data["numFailed"] = this.numFailed;
        data["lastExecuted"] = this.lastExecuted ? this.lastExecuted.toISOString() : <any>undefined;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IRuleDto extends IResourceDto {
    /** The ID of the rule. */
    readonly id: string;
    /** The user that has created the rule. */
    readonly createdBy: string;
    /** The user that has updated the rule. */
    readonly lastModifiedBy: string;
    /** The date and time when the rule has been created. */
    readonly created: DateTime;
    /** The date and time when the rule has been modified last. */
    readonly lastModified: DateTime;
    /** The version of the rule. */
    readonly version: number;
    /** Determines if the rule is enabled. */
    readonly isEnabled: boolean;
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger: RuleTriggerDto;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow: FlowDefinitionDto;
    /** The action properties. */
    readonly action: RuleActionDto;
    /** The number of completed executions. */
    readonly numSucceeded: number;
    /** The number of failed executions. */
    readonly numFailed: number;
    /** The date and time when the rule was executed the last time. */
    readonly lastExecuted?: DateTime | undefined;
}

export abstract class RuleTriggerDto implements IRuleTriggerDto {
    /** The discriminator. */
    public readonly triggerType!: string;
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};

    constructor(data?: IRuleTriggerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        (<any>this).triggerType = "RuleTriggerDto";
    }

    init(_data: any) {
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RuleTriggerDto {
        if (data["triggerType"] === "AssetChanged") {
            return new AssetChangedRuleTriggerDto().init(data);
        }
        if (data["triggerType"] === "Comment") {
            return new CommentRuleTriggerDto().init(data);
        }
        if (data["triggerType"] === "ContentChanged") {
            return new ContentChangedRuleTriggerDto().init(data);
        }
        if (data["triggerType"] === "Manual") {
            return new ManualRuleTriggerDto().init(data);
        }
        if (data["triggerType"] === "SchemaChanged") {
            return new SchemaChangedRuleTriggerDto().init(data);
        }
        if (data["triggerType"] === "Usage") {
            return new UsageRuleTriggerDto().init(data);
        }
        throw new Error("The abstract class 'RuleTriggerDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["triggerType"] = this.triggerType;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IRuleTriggerDto {
}

export class AssetChangedRuleTriggerDto extends RuleTriggerDto implements IAssetChangedRuleTriggerDto {
    /** Javascript condition when to trigger. */
    readonly condition?: string | undefined;

    constructor(data?: IAssetChangedRuleTriggerDto) {
        super(data);
        (<any>this).triggerType = "AssetChanged";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).condition = _data["condition"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AssetChangedRuleTriggerDto {
        const result = new AssetChangedRuleTriggerDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["condition"] = this.condition;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAssetChangedRuleTriggerDto extends IRuleTriggerDto {
    /** Javascript condition when to trigger. */
    readonly condition?: string | undefined;
}

export class CommentRuleTriggerDto extends RuleTriggerDto implements ICommentRuleTriggerDto {
    /** Javascript condition when to trigger. */
    readonly condition?: string | undefined;

    constructor(data?: ICommentRuleTriggerDto) {
        super(data);
        (<any>this).triggerType = "Comment";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).condition = _data["condition"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CommentRuleTriggerDto {
        const result = new CommentRuleTriggerDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["condition"] = this.condition;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ICommentRuleTriggerDto extends IRuleTriggerDto {
    /** Javascript condition when to trigger. */
    readonly condition?: string | undefined;
}

export class ContentChangedRuleTriggerDto extends RuleTriggerDto implements IContentChangedRuleTriggerDto {
    /** The schema settings. */
    readonly schemas?: SchemaConditionDto[] | undefined;
    /** The schema references. */
    readonly referencedSchemas?: SchemaConditionDto[] | undefined;
    /** Determines whether the trigger should handle all content changes events. */
    readonly handleAll!: boolean;

    constructor(data?: IContentChangedRuleTriggerDto) {
        super(data);
        (<any>this).triggerType = "ContentChanged";
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["schemas"])) {
            (<any>this).schemas = [] as any;
            for (let item of _data["schemas"])
                (<any>this).schemas!.push(SchemaConditionDto.fromJSON(item));
        }
        if (Array.isArray(_data["referencedSchemas"])) {
            (<any>this).referencedSchemas = [] as any;
            for (let item of _data["referencedSchemas"])
                (<any>this).referencedSchemas!.push(SchemaConditionDto.fromJSON(item));
        }
        (<any>this).handleAll = _data["handleAll"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ContentChangedRuleTriggerDto {
        const result = new ContentChangedRuleTriggerDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.schemas)) {
            data["schemas"] = [];
            for (let item of this.schemas)
                data["schemas"].push(item.toJSON());
        }
        if (Array.isArray(this.referencedSchemas)) {
            data["referencedSchemas"] = [];
            for (let item of this.referencedSchemas)
                data["referencedSchemas"].push(item.toJSON());
        }
        data["handleAll"] = this.handleAll;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IContentChangedRuleTriggerDto extends IRuleTriggerDto {
    /** The schema settings. */
    readonly schemas?: SchemaConditionDto[] | undefined;
    /** The schema references. */
    readonly referencedSchemas?: SchemaConditionDto[] | undefined;
    /** Determines whether the trigger should handle all content changes events. */
    readonly handleAll: boolean;
}

export class SchemaConditionDto implements ISchemaConditionDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    readonly schemaId!: string;
    readonly condition?: string | undefined;

    constructor(data?: ISchemaConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).schemaId = _data["schemaId"];
        (<any>this).condition = _data["condition"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SchemaConditionDto {
        const result = new SchemaConditionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["schemaId"] = this.schemaId;
        data["condition"] = this.condition;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ISchemaConditionDto {
    readonly schemaId: string;
    readonly condition?: string | undefined;
}

export class ManualRuleTriggerDto extends RuleTriggerDto implements IManualRuleTriggerDto {

    constructor(data?: IManualRuleTriggerDto) {
        super(data);
        (<any>this).triggerType = "Manual";
    }

    init(_data: any) {
        super.init(_data);
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ManualRuleTriggerDto {
        const result = new ManualRuleTriggerDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IManualRuleTriggerDto extends IRuleTriggerDto {
}

export class SchemaChangedRuleTriggerDto extends RuleTriggerDto implements ISchemaChangedRuleTriggerDto {
    /** Javascript condition when to trigger. */
    readonly condition?: string | undefined;

    constructor(data?: ISchemaChangedRuleTriggerDto) {
        super(data);
        (<any>this).triggerType = "SchemaChanged";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).condition = _data["condition"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SchemaChangedRuleTriggerDto {
        const result = new SchemaChangedRuleTriggerDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["condition"] = this.condition;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISchemaChangedRuleTriggerDto extends IRuleTriggerDto {
    /** Javascript condition when to trigger. */
    readonly condition?: string | undefined;
}

export class UsageRuleTriggerDto extends RuleTriggerDto implements IUsageRuleTriggerDto {
    /** The number of monthly api calls. */
    readonly limit!: number;
    /** The number of days to check or null for the current month. */
    readonly numDays?: number | undefined;

    constructor(data?: IUsageRuleTriggerDto) {
        super(data);
        (<any>this).triggerType = "Usage";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).limit = _data["limit"];
        (<any>this).numDays = _data["numDays"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UsageRuleTriggerDto {
        const result = new UsageRuleTriggerDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["limit"] = this.limit;
        data["numDays"] = this.numDays;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IUsageRuleTriggerDto extends IRuleTriggerDto {
    /** The number of monthly api calls. */
    readonly limit: number;
    /** The number of days to check or null for the current month. */
    readonly numDays?: number | undefined;
}

export class FlowDefinitionDto implements IFlowDefinitionDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The ID of the initial step. */
    readonly initialStepId!: string;
    /** The steps. */
    readonly steps!: { [key: string]: FlowStepDefinitionDto; };

    constructor(data?: IFlowDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).initialStepId = _data["initialStepId"];
        if (_data["steps"]) {
            (<any>this).steps = {} as any;
            for (let key in _data["steps"]) {
                if (_data["steps"].hasOwnProperty(key))
                    (<any>(<any>this).steps)![key] = _data["steps"][key] ? FlowStepDefinitionDto.fromJSON(_data["steps"][key]) : new FlowStepDefinitionDto();
            }
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FlowDefinitionDto {
        const result = new FlowDefinitionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["initialStepId"] = this.initialStepId;
        if (this.steps) {
            data["steps"] = {};
            for (let key in this.steps) {
                if (this.steps.hasOwnProperty(key))
                    (<any>data["steps"])[key] = this.steps[key] ? this.steps[key].toJSON() : <any>undefined;
            }
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFlowDefinitionDto {
    /** The ID of the initial step. */
    readonly initialStepId: string;
    /** The steps. */
    readonly steps: { [key: string]: FlowStepDefinitionDto; };
}

export class FlowStepDefinitionDto implements IFlowStepDefinitionDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The actual step. */
    readonly step!: FlowStepDto;
    /** The optional descriptive name. */
    readonly name?: string | undefined;
    /** The next step. */
    readonly nextStepId?: string | undefined;
    /** Indicates if errors should be ignored. */
    readonly ignoreError?: boolean;

    constructor(data?: IFlowStepDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).step = _data["step"] ? FlowStepDto.fromJSON(_data["step"]) : <any>undefined;
        (<any>this).name = _data["name"];
        (<any>this).nextStepId = _data["nextStepId"];
        (<any>this).ignoreError = _data["ignoreError"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FlowStepDefinitionDto {
        const result = new FlowStepDefinitionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["step"] = this.step ? this.step.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["nextStepId"] = this.nextStepId;
        data["ignoreError"] = this.ignoreError;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFlowStepDefinitionDto {
    /** The actual step. */
    readonly step: FlowStepDto;
    /** The optional descriptive name. */
    readonly name?: string | undefined;
    /** The next step. */
    readonly nextStepId?: string | undefined;
    /** Indicates if errors should be ignored. */
    readonly ignoreError?: boolean;
}

export abstract class FlowStepDto implements IFlowStepDto {
    /** The discriminator. */
    public readonly stepType!: string;
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};

    constructor(data?: IFlowStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        (<any>this).stepType = "FlowStepDto";
    }

    init(_data: any) {
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FlowStepDto {
        if (data["stepType"] === "Algolia") {
            return new AlgoliaFlowStepDto().init(data);
        }
        if (data["stepType"] === "AzureQueue") {
            return new AzureQueueFlowStepDto().init(data);
        }
        if (data["stepType"] === "Comment") {
            return new CommentFlowStepDto().init(data);
        }
        if (data["stepType"] === "CreateContent") {
            return new CreateContentFlowStepDto().init(data);
        }
        if (data["stepType"] === "Delay") {
            return new DelayFlowStepDto().init(data);
        }
        if (data["stepType"] === "Discourse") {
            return new DiscourseFlowStepDto().init(data);
        }
        if (data["stepType"] === "ElasticSearch") {
            return new ElasticSearchFlowStepDto().init(data);
        }
        if (data["stepType"] === "Email") {
            return new EmailFlowStepDto().init(data);
        }
        if (data["stepType"] === "Fastly") {
            return new FastlyFlowStepDto().init(data);
        }
        if (data["stepType"] === "If") {
            return new IfFlowStepDto().init(data);
        }
        if (data["stepType"] === "Medium") {
            return new MediumFlowStepDto().init(data);
        }
        if (data["stepType"] === "Notification") {
            return new NotificationFlowStepDto().init(data);
        }
        if (data["stepType"] === "OpenSearch") {
            return new OpenSearchFlowStepDto().init(data);
        }
        if (data["stepType"] === "Prerender") {
            return new PrerenderFlowStepDto().init(data);
        }
        if (data["stepType"] === "Script") {
            return new ScriptFlowStepDto().init(data);
        }
        if (data["stepType"] === "SignalR") {
            return new SignalRFlowStepDto().init(data);
        }
        if (data["stepType"] === "Slack") {
            return new SlackFlowStepDto().init(data);
        }
        if (data["stepType"] === "Tweet") {
            return new TweetFlowStepDto().init(data);
        }
        if (data["stepType"] === "Typesense") {
            return new TypesenseFlowStepDto().init(data);
        }
        if (data["stepType"] === "Webhook") {
            return new WebhookFlowStepDto().init(data);
        }
        throw new Error("The abstract class 'FlowStepDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["stepType"] = this.stepType;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFlowStepDto {
}

export class AlgoliaFlowStepDto extends FlowStepDto implements IAlgoliaFlowStepDto {
    /** The application ID. */
    readonly appId!: string;
    /** The API key to grant access to Squidex. */
    readonly apiKey!: string;
    /** The name of the index. */
    readonly indexName!: string;
    /** The optional custom document. */
    readonly document?: string | undefined;
    /** The condition when to delete the entry. */
    readonly delete?: string | undefined;

    constructor(data?: IAlgoliaFlowStepDto) {
        super(data);
        (<any>this).stepType = "Algolia";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).appId = _data["appId"];
        (<any>this).apiKey = _data["apiKey"];
        (<any>this).indexName = _data["indexName"];
        (<any>this).document = _data["document"];
        (<any>this).delete = _data["delete"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AlgoliaFlowStepDto {
        const result = new AlgoliaFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["appId"] = this.appId;
        data["apiKey"] = this.apiKey;
        data["indexName"] = this.indexName;
        data["document"] = this.document;
        data["delete"] = this.delete;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAlgoliaFlowStepDto extends IFlowStepDto {
    /** The application ID. */
    readonly appId: string;
    /** The API key to grant access to Squidex. */
    readonly apiKey: string;
    /** The name of the index. */
    readonly indexName: string;
    /** The optional custom document. */
    readonly document?: string | undefined;
    /** The condition when to delete the entry. */
    readonly delete?: string | undefined;
}

export class AzureQueueFlowStepDto extends FlowStepDto implements IAzureQueueFlowStepDto {
    /** The connection string to the storage account. */
    readonly connectionString!: string;
    /** The name of the queue. */
    readonly queue!: string;
    /** Leave it empty to use the full event as body. */
    readonly payload?: string | undefined;

    constructor(data?: IAzureQueueFlowStepDto) {
        super(data);
        (<any>this).stepType = "AzureQueue";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).connectionString = _data["connectionString"];
        (<any>this).queue = _data["queue"];
        (<any>this).payload = _data["payload"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AzureQueueFlowStepDto {
        const result = new AzureQueueFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["connectionString"] = this.connectionString;
        data["queue"] = this.queue;
        data["payload"] = this.payload;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAzureQueueFlowStepDto extends IFlowStepDto {
    /** The connection string to the storage account. */
    readonly connectionString: string;
    /** The name of the queue. */
    readonly queue: string;
    /** Leave it empty to use the full event as body. */
    readonly payload?: string | undefined;
}

export class CommentFlowStepDto extends FlowStepDto implements ICommentFlowStepDto {
    /** The comment text. */
    readonly text!: string;
    /** An optional client name. */
    readonly client?: string | undefined;

    constructor(data?: ICommentFlowStepDto) {
        super(data);
        (<any>this).stepType = "Comment";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).text = _data["text"];
        (<any>this).client = _data["client"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CommentFlowStepDto {
        const result = new CommentFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["text"] = this.text;
        data["client"] = this.client;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ICommentFlowStepDto extends IFlowStepDto {
    /** The comment text. */
    readonly text: string;
    /** An optional client name. */
    readonly client?: string | undefined;
}

export class CreateContentFlowStepDto extends FlowStepDto implements ICreateContentFlowStepDto {
    /** The content data. */
    readonly data!: string;
    /** The name of the schema. */
    readonly schema!: string;
    /** An optional client name. */
    readonly client?: string | undefined;
    /** Publish the content. */
    readonly publish!: boolean;

    constructor(data?: ICreateContentFlowStepDto) {
        super(data);
        (<any>this).stepType = "CreateContent";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).data = _data["data"];
        (<any>this).schema = _data["schema"];
        (<any>this).client = _data["client"];
        (<any>this).publish = _data["publish"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateContentFlowStepDto {
        const result = new CreateContentFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["data"] = this.data;
        data["schema"] = this.schema;
        data["client"] = this.client;
        data["publish"] = this.publish;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ICreateContentFlowStepDto extends IFlowStepDto {
    /** The content data. */
    readonly data: string;
    /** The name of the schema. */
    readonly schema: string;
    /** An optional client name. */
    readonly client?: string | undefined;
    /** Publish the content. */
    readonly publish: boolean;
}

export class DelayFlowStepDto extends FlowStepDto implements IDelayFlowStepDto {
    /** The delay in seconds. */
    readonly delayInSec!: number;

    constructor(data?: IDelayFlowStepDto) {
        super(data);
        (<any>this).stepType = "Delay";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).delayInSec = _data["delayInSec"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DelayFlowStepDto {
        const result = new DelayFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["delayInSec"] = this.delayInSec;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IDelayFlowStepDto extends IFlowStepDto {
    /** The delay in seconds. */
    readonly delayInSec: number;
}

export class DiscourseFlowStepDto extends FlowStepDto implements IDiscourseFlowStepDto {
    /** The url to the discourse server. */
    readonly url!: string;
    /** The api key to authenticate to your discourse server. */
    readonly apiKey!: string;
    /** The api username to authenticate to your discourse server. */
    readonly apiUsername!: string;
    /** The text as markdown. */
    readonly text!: string;
    /** The optional title when creating new topics. */
    readonly title?: string | undefined;
    /** The optional topic id. */
    readonly topic?: number | undefined;
    /** The optional category id. */
    readonly category?: number | undefined;

    constructor(data?: IDiscourseFlowStepDto) {
        super(data);
        (<any>this).stepType = "Discourse";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).url = _data["url"];
        (<any>this).apiKey = _data["apiKey"];
        (<any>this).apiUsername = _data["apiUsername"];
        (<any>this).text = _data["text"];
        (<any>this).title = _data["title"];
        (<any>this).topic = _data["topic"];
        (<any>this).category = _data["category"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DiscourseFlowStepDto {
        const result = new DiscourseFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["url"] = this.url;
        data["apiKey"] = this.apiKey;
        data["apiUsername"] = this.apiUsername;
        data["text"] = this.text;
        data["title"] = this.title;
        data["topic"] = this.topic;
        data["category"] = this.category;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IDiscourseFlowStepDto extends IFlowStepDto {
    /** The url to the discourse server. */
    readonly url: string;
    /** The api key to authenticate to your discourse server. */
    readonly apiKey: string;
    /** The api username to authenticate to your discourse server. */
    readonly apiUsername: string;
    /** The text as markdown. */
    readonly text: string;
    /** The optional title when creating new topics. */
    readonly title?: string | undefined;
    /** The optional topic id. */
    readonly topic?: number | undefined;
    /** The optional category id. */
    readonly category?: number | undefined;
}

export class ElasticSearchFlowStepDto extends FlowStepDto implements IElasticSearchFlowStepDto {
    /** The url to the instance or cluster. */
    readonly host!: string;
    /** The name of the index. */
    readonly indexName!: string;
    /** The optional username. */
    readonly username?: string | undefined;
    /** The optional password. */
    readonly password?: string | undefined;
    /** The optional custom document. */
    readonly document?: string | undefined;
    /** The condition when to delete the document. */
    readonly delete?: string | undefined;

    constructor(data?: IElasticSearchFlowStepDto) {
        super(data);
        (<any>this).stepType = "ElasticSearch";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).host = _data["host"];
        (<any>this).indexName = _data["indexName"];
        (<any>this).username = _data["username"];
        (<any>this).password = _data["password"];
        (<any>this).document = _data["document"];
        (<any>this).delete = _data["delete"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ElasticSearchFlowStepDto {
        const result = new ElasticSearchFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["host"] = this.host;
        data["indexName"] = this.indexName;
        data["username"] = this.username;
        data["password"] = this.password;
        data["document"] = this.document;
        data["delete"] = this.delete;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IElasticSearchFlowStepDto extends IFlowStepDto {
    /** The url to the instance or cluster. */
    readonly host: string;
    /** The name of the index. */
    readonly indexName: string;
    /** The optional username. */
    readonly username?: string | undefined;
    /** The optional password. */
    readonly password?: string | undefined;
    /** The optional custom document. */
    readonly document?: string | undefined;
    /** The condition when to delete the document. */
    readonly delete?: string | undefined;
}

export class EmailFlowStepDto extends FlowStepDto implements IEmailFlowStepDto {
    /** The IP address or host to the SMTP server. */
    readonly serverHost!: string;
    /** The port to the SMTP server. */
    readonly serverPort!: number;
    /** The username for the SMTP server. */
    readonly serverUsername!: string;
    /** The password for the SMTP server. */
    readonly serverPassword!: string;
    /** The email sending address. */
    readonly messageFrom!: string;
    /** The email message will be sent to. */
    readonly messageTo!: string;
    /** The subject line for this email message. */
    readonly messageSubject!: string;
    /** The message body. */
    readonly messageBody!: string;

    constructor(data?: IEmailFlowStepDto) {
        super(data);
        (<any>this).stepType = "Email";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).serverHost = _data["serverHost"];
        (<any>this).serverPort = _data["serverPort"];
        (<any>this).serverUsername = _data["serverUsername"];
        (<any>this).serverPassword = _data["serverPassword"];
        (<any>this).messageFrom = _data["messageFrom"];
        (<any>this).messageTo = _data["messageTo"];
        (<any>this).messageSubject = _data["messageSubject"];
        (<any>this).messageBody = _data["messageBody"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): EmailFlowStepDto {
        const result = new EmailFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["serverHost"] = this.serverHost;
        data["serverPort"] = this.serverPort;
        data["serverUsername"] = this.serverUsername;
        data["serverPassword"] = this.serverPassword;
        data["messageFrom"] = this.messageFrom;
        data["messageTo"] = this.messageTo;
        data["messageSubject"] = this.messageSubject;
        data["messageBody"] = this.messageBody;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IEmailFlowStepDto extends IFlowStepDto {
    /** The IP address or host to the SMTP server. */
    readonly serverHost: string;
    /** The port to the SMTP server. */
    readonly serverPort: number;
    /** The username for the SMTP server. */
    readonly serverUsername: string;
    /** The password for the SMTP server. */
    readonly serverPassword: string;
    /** The email sending address. */
    readonly messageFrom: string;
    /** The email message will be sent to. */
    readonly messageTo: string;
    /** The subject line for this email message. */
    readonly messageSubject: string;
    /** The message body. */
    readonly messageBody: string;
}

export class FastlyFlowStepDto extends FlowStepDto implements IFastlyFlowStepDto {
    /** The API key to grant access to Squidex. */
    readonly apiKey!: string;
    /** The ID of the fastly service. */
    readonly serviceId!: string;

    constructor(data?: IFastlyFlowStepDto) {
        super(data);
        (<any>this).stepType = "Fastly";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).apiKey = _data["apiKey"];
        (<any>this).serviceId = _data["serviceId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FastlyFlowStepDto {
        const result = new FastlyFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["apiKey"] = this.apiKey;
        data["serviceId"] = this.serviceId;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IFastlyFlowStepDto extends IFlowStepDto {
    /** The API key to grant access to Squidex. */
    readonly apiKey: string;
    /** The ID of the fastly service. */
    readonly serviceId: string;
}

export class IfFlowStepDto extends FlowStepDto implements IIfFlowStepDto {
    /** The delay in seconds. */
    readonly branches!: IfFlowBranchDto[];
    readonly elseStepId?: string | undefined;

    constructor(data?: IIfFlowStepDto) {
        super(data);
        (<any>this).stepType = "If";
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["branches"])) {
            (<any>this).branches = [] as any;
            for (let item of _data["branches"])
                (<any>this).branches!.push(IfFlowBranchDto.fromJSON(item));
        }
        (<any>this).elseStepId = _data["elseStepId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): IfFlowStepDto {
        const result = new IfFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.branches)) {
            data["branches"] = [];
            for (let item of this.branches)
                data["branches"].push(item.toJSON());
        }
        data["elseStepId"] = this.elseStepId;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IIfFlowStepDto extends IFlowStepDto {
    /** The delay in seconds. */
    readonly branches: IfFlowBranchDto[];
    readonly elseStepId?: string | undefined;
}

export class IfFlowBranchDto implements IIfFlowBranchDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    readonly condition?: string | undefined;
    readonly nextStepId?: string | undefined;

    constructor(data?: IIfFlowBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).condition = _data["condition"];
        (<any>this).nextStepId = _data["nextStepId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): IfFlowBranchDto {
        const result = new IfFlowBranchDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["condition"] = this.condition;
        data["nextStepId"] = this.nextStepId;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IIfFlowBranchDto {
    readonly condition?: string | undefined;
    readonly nextStepId?: string | undefined;
}

export class MediumFlowStepDto extends FlowStepDto implements IMediumFlowStepDto {
    /** The self issued access token. */
    readonly accessToken!: string;
    /** The title, used for the url. */
    readonly title!: string;
    /** The content, either html or markdown. */
    readonly content!: string;
    /** The original home of this content, if it was originally published elsewhere. */
    readonly canonicalUrl?: string | undefined;
    /** The optional comma separated list of tags. */
    readonly tags?: string | undefined;
    /** Optional publication id. */
    readonly publicationId?: string | undefined;
    /** Indicates whether the content is markdown or html. */
    readonly isHtml!: boolean;

    constructor(data?: IMediumFlowStepDto) {
        super(data);
        (<any>this).stepType = "Medium";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).accessToken = _data["accessToken"];
        (<any>this).title = _data["title"];
        (<any>this).content = _data["content"];
        (<any>this).canonicalUrl = _data["canonicalUrl"];
        (<any>this).tags = _data["tags"];
        (<any>this).publicationId = _data["publicationId"];
        (<any>this).isHtml = _data["isHtml"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): MediumFlowStepDto {
        const result = new MediumFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["accessToken"] = this.accessToken;
        data["title"] = this.title;
        data["content"] = this.content;
        data["canonicalUrl"] = this.canonicalUrl;
        data["tags"] = this.tags;
        data["publicationId"] = this.publicationId;
        data["isHtml"] = this.isHtml;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IMediumFlowStepDto extends IFlowStepDto {
    /** The self issued access token. */
    readonly accessToken: string;
    /** The title, used for the url. */
    readonly title: string;
    /** The content, either html or markdown. */
    readonly content: string;
    /** The original home of this content, if it was originally published elsewhere. */
    readonly canonicalUrl?: string | undefined;
    /** The optional comma separated list of tags. */
    readonly tags?: string | undefined;
    /** Optional publication id. */
    readonly publicationId?: string | undefined;
    /** Indicates whether the content is markdown or html. */
    readonly isHtml: boolean;
}

export class NotificationFlowStepDto extends FlowStepDto implements INotificationFlowStepDto {
    /** The user id or email. */
    readonly user!: string;
    /** The text to send. */
    readonly text!: string;
    /** The optional url to attach to the notification. */
    readonly url?: string | undefined;
    /** An optional client name. */
    readonly client?: string | undefined;

    constructor(data?: INotificationFlowStepDto) {
        super(data);
        (<any>this).stepType = "Notification";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).user = _data["user"];
        (<any>this).text = _data["text"];
        (<any>this).url = _data["url"];
        (<any>this).client = _data["client"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): NotificationFlowStepDto {
        const result = new NotificationFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["user"] = this.user;
        data["text"] = this.text;
        data["url"] = this.url;
        data["client"] = this.client;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface INotificationFlowStepDto extends IFlowStepDto {
    /** The user id or email. */
    readonly user: string;
    /** The text to send. */
    readonly text: string;
    /** The optional url to attach to the notification. */
    readonly url?: string | undefined;
    /** An optional client name. */
    readonly client?: string | undefined;
}

export class OpenSearchFlowStepDto extends FlowStepDto implements IOpenSearchFlowStepDto {
    /** The url to the instance or cluster. */
    readonly host!: string;
    /** The name of the index. */
    readonly indexName!: string;
    /** The optional username. */
    readonly username?: string | undefined;
    /** The optional password. */
    readonly password?: string | undefined;
    /** The optional custom document. */
    readonly document?: string | undefined;
    /** The condition when to delete the document. */
    readonly delete?: string | undefined;

    constructor(data?: IOpenSearchFlowStepDto) {
        super(data);
        (<any>this).stepType = "OpenSearch";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).host = _data["host"];
        (<any>this).indexName = _data["indexName"];
        (<any>this).username = _data["username"];
        (<any>this).password = _data["password"];
        (<any>this).document = _data["document"];
        (<any>this).delete = _data["delete"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): OpenSearchFlowStepDto {
        const result = new OpenSearchFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["host"] = this.host;
        data["indexName"] = this.indexName;
        data["username"] = this.username;
        data["password"] = this.password;
        data["document"] = this.document;
        data["delete"] = this.delete;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IOpenSearchFlowStepDto extends IFlowStepDto {
    /** The url to the instance or cluster. */
    readonly host: string;
    /** The name of the index. */
    readonly indexName: string;
    /** The optional username. */
    readonly username?: string | undefined;
    /** The optional password. */
    readonly password?: string | undefined;
    /** The optional custom document. */
    readonly document?: string | undefined;
    /** The condition when to delete the document. */
    readonly delete?: string | undefined;
}

export class PrerenderFlowStepDto extends FlowStepDto implements IPrerenderFlowStepDto {
    /** The prerender token from your account. */
    readonly token!: string;
    /** The url to recache. */
    readonly url!: string;

    constructor(data?: IPrerenderFlowStepDto) {
        super(data);
        (<any>this).stepType = "Prerender";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).token = _data["token"];
        (<any>this).url = _data["url"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): PrerenderFlowStepDto {
        const result = new PrerenderFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["token"] = this.token;
        data["url"] = this.url;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IPrerenderFlowStepDto extends IFlowStepDto {
    /** The prerender token from your account. */
    readonly token: string;
    /** The url to recache. */
    readonly url: string;
}

export class ScriptFlowStepDto extends FlowStepDto implements IScriptFlowStepDto {
    /** The script to execute. */
    readonly script?: string | undefined;

    constructor(data?: IScriptFlowStepDto) {
        super(data);
        (<any>this).stepType = "Script";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).script = _data["script"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ScriptFlowStepDto {
        const result = new ScriptFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["script"] = this.script;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IScriptFlowStepDto extends IFlowStepDto {
    /** The script to execute. */
    readonly script?: string | undefined;
}

export class SignalRFlowStepDto extends FlowStepDto implements ISignalRFlowStepDto {
    /** The connection string to the Azure SignalR. */
    readonly connectionString!: string;
    /** The name of the hub. */
    readonly hubName!: string;
    /** * Broadcast = send to all users.
 * User = send to all target users(s).
 * Group = send to all target group(s). */
    readonly action!: SignalRActionType;
    /** Set the Name of the hub method received by the customer. */
    readonly methodName?: string | undefined;
    /** Define target users or groups by id or name. One item per line. Not needed for Broadcast action. */
    readonly target?: string | undefined;
    /** Leave it empty to use the full event as body. */
    readonly payload?: string | undefined;

    constructor(data?: ISignalRFlowStepDto) {
        super(data);
        (<any>this).stepType = "SignalR";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).connectionString = _data["connectionString"];
        (<any>this).hubName = _data["hubName"];
        (<any>this).action = _data["action"];
        (<any>this).methodName = _data["methodName"];
        (<any>this).target = _data["target"];
        (<any>this).payload = _data["payload"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SignalRFlowStepDto {
        const result = new SignalRFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["connectionString"] = this.connectionString;
        data["hubName"] = this.hubName;
        data["action"] = this.action;
        data["methodName"] = this.methodName;
        data["target"] = this.target;
        data["payload"] = this.payload;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISignalRFlowStepDto extends IFlowStepDto {
    /** The connection string to the Azure SignalR. */
    readonly connectionString: string;
    /** The name of the hub. */
    readonly hubName: string;
    /** * Broadcast = send to all users.
 * User = send to all target users(s).
 * Group = send to all target group(s). */
    readonly action: SignalRActionType;
    /** Set the Name of the hub method received by the customer. */
    readonly methodName?: string | undefined;
    /** Define target users or groups by id or name. One item per line. Not needed for Broadcast action. */
    readonly target?: string | undefined;
    /** Leave it empty to use the full event as body. */
    readonly payload?: string | undefined;
}

export type SignalRActionType = "Broadcast" | "User" | "Group";

export const SignalRActionTypeValues: ReadonlyArray<SignalRActionType> = [
	"Broadcast",
	"User",
	"Group"
];

export class SlackFlowStepDto extends FlowStepDto implements ISlackFlowStepDto {
    /** The slack webhook url. */
    readonly webhookUrl!: string;
    /** The text that is sent as message to slack. */
    readonly text!: string;

    constructor(data?: ISlackFlowStepDto) {
        super(data);
        (<any>this).stepType = "Slack";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).webhookUrl = _data["webhookUrl"];
        (<any>this).text = _data["text"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SlackFlowStepDto {
        const result = new SlackFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["webhookUrl"] = this.webhookUrl;
        data["text"] = this.text;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISlackFlowStepDto extends IFlowStepDto {
    /** The slack webhook url. */
    readonly webhookUrl: string;
    /** The text that is sent as message to slack. */
    readonly text: string;
}

export class TweetFlowStepDto extends FlowStepDto implements ITweetFlowStepDto {
    /** The generated access token. */
    readonly accessToken!: string;
    /** The generated access secret. */
    readonly accessSecret!: string;
    /** The text that is sent as tweet to twitter. */
    readonly text!: string;

    constructor(data?: ITweetFlowStepDto) {
        super(data);
        (<any>this).stepType = "Tweet";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).accessToken = _data["accessToken"];
        (<any>this).accessSecret = _data["accessSecret"];
        (<any>this).text = _data["text"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TweetFlowStepDto {
        const result = new TweetFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["accessToken"] = this.accessToken;
        data["accessSecret"] = this.accessSecret;
        data["text"] = this.text;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ITweetFlowStepDto extends IFlowStepDto {
    /** The generated access token. */
    readonly accessToken: string;
    /** The generated access secret. */
    readonly accessSecret: string;
    /** The text that is sent as tweet to twitter. */
    readonly text: string;
}

export class TypesenseFlowStepDto extends FlowStepDto implements ITypesenseFlowStepDto {
    /** The url to the instance or cluster. */
    readonly host!: string;
    /** The name of the index. */
    readonly indexName!: string;
    /** The api key. */
    readonly apiKey!: string;
    /** The optional custom document. */
    readonly document?: string | undefined;
    /** The condition when to delete the document. */
    readonly delete?: string | undefined;

    constructor(data?: ITypesenseFlowStepDto) {
        super(data);
        (<any>this).stepType = "Typesense";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).host = _data["host"];
        (<any>this).indexName = _data["indexName"];
        (<any>this).apiKey = _data["apiKey"];
        (<any>this).document = _data["document"];
        (<any>this).delete = _data["delete"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TypesenseFlowStepDto {
        const result = new TypesenseFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["host"] = this.host;
        data["indexName"] = this.indexName;
        data["apiKey"] = this.apiKey;
        data["document"] = this.document;
        data["delete"] = this.delete;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ITypesenseFlowStepDto extends IFlowStepDto {
    /** The url to the instance or cluster. */
    readonly host: string;
    /** The name of the index. */
    readonly indexName: string;
    /** The api key. */
    readonly apiKey: string;
    /** The optional custom document. */
    readonly document?: string | undefined;
    /** The condition when to delete the document. */
    readonly delete?: string | undefined;
}

export class WebhookFlowStepDto extends FlowStepDto implements IWebhookFlowStepDto {
    /** The type of the request. */
    readonly method!: WebhookMethod;
    /** The URL to the webhook. */
    readonly url!: string;
    /** Leave it empty to use the full event as body. */
    readonly payload?: string | undefined;
    /** The message headers in the format '[Key]=[Value]', one entry per line. */
    readonly headers?: string | undefined;
    /** The mime type of the payload. */
    readonly payloadType?: string | undefined;
    /** The shared secret that is used to calculate the payload signature. */
    readonly sharedSecret?: string | undefined;

    constructor(data?: IWebhookFlowStepDto) {
        super(data);
        (<any>this).stepType = "Webhook";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).method = _data["method"];
        (<any>this).url = _data["url"];
        (<any>this).payload = _data["payload"];
        (<any>this).headers = _data["headers"];
        (<any>this).payloadType = _data["payloadType"];
        (<any>this).sharedSecret = _data["sharedSecret"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): WebhookFlowStepDto {
        const result = new WebhookFlowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["method"] = this.method;
        data["url"] = this.url;
        data["payload"] = this.payload;
        data["headers"] = this.headers;
        data["payloadType"] = this.payloadType;
        data["sharedSecret"] = this.sharedSecret;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IWebhookFlowStepDto extends IFlowStepDto {
    /** The type of the request. */
    readonly method: WebhookMethod;
    /** The URL to the webhook. */
    readonly url: string;
    /** Leave it empty to use the full event as body. */
    readonly payload?: string | undefined;
    /** The message headers in the format '[Key]=[Value]', one entry per line. */
    readonly headers?: string | undefined;
    /** The mime type of the payload. */
    readonly payloadType?: string | undefined;
    /** The shared secret that is used to calculate the payload signature. */
    readonly sharedSecret?: string | undefined;
}

export type WebhookMethod = "POST" | "PUT" | "GET" | "DELETE" | "PATCH";

export const WebhookMethodValues: ReadonlyArray<WebhookMethod> = [
	"POST",
	"PUT",
	"GET",
	"DELETE",
	"PATCH"
];

export abstract class RuleActionDto implements IRuleActionDto {
    /** The discriminator. */
    public readonly actionType!: string;
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};

    constructor(data?: IRuleActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        (<any>this).actionType = "RuleActionDto";
    }

    init(_data: any) {
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RuleActionDto {
        if (data["actionType"] === "Algolia") {
            return new AlgoliaRuleActionDto().init(data);
        }
        if (data["actionType"] === "AzureQueue") {
            return new AzureQueueRuleActionDto().init(data);
        }
        if (data["actionType"] === "Comment") {
            return new CommentRuleActionDto().init(data);
        }
        if (data["actionType"] === "CreateContent") {
            return new CreateContentRuleActionDto().init(data);
        }
        if (data["actionType"] === "Discourse") {
            return new DiscourseRuleActionDto().init(data);
        }
        if (data["actionType"] === "ElasticSearch") {
            return new ElasticSearchRuleActionDto().init(data);
        }
        if (data["actionType"] === "Email") {
            return new EmailRuleActionDto().init(data);
        }
        if (data["actionType"] === "Fastly") {
            return new FastlyRuleActionDto().init(data);
        }
        if (data["actionType"] === "Medium") {
            return new MediumRuleActionDto().init(data);
        }
        if (data["actionType"] === "Notification") {
            return new NotificationRuleActionDto().init(data);
        }
        if (data["actionType"] === "OpenSearch") {
            return new OpenSearchRuleActionDto().init(data);
        }
        if (data["actionType"] === "Prerender") {
            return new PrerenderRuleActionDto().init(data);
        }
        if (data["actionType"] === "Script") {
            return new ScriptRuleActionDto().init(data);
        }
        if (data["actionType"] === "SignalR") {
            return new SignalRRuleActionDto().init(data);
        }
        if (data["actionType"] === "Slack") {
            return new SlackRuleActionDto().init(data);
        }
        if (data["actionType"] === "Tweet") {
            return new TweetRuleActionDto().init(data);
        }
        if (data["actionType"] === "Typesense") {
            return new TypesenseRuleActionDto().init(data);
        }
        if (data["actionType"] === "Webhook") {
            return new WebhookRuleActionDto().init(data);
        }
        throw new Error("The abstract class 'RuleActionDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["actionType"] = this.actionType;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IRuleActionDto {
}

export class AlgoliaRuleActionDto extends RuleActionDto implements IAlgoliaRuleActionDto {
    readonly appId!: string;
    readonly apiKey!: string;
    readonly indexName!: string;
    readonly document?: string | undefined;
    readonly delete?: string | undefined;

    constructor(data?: IAlgoliaRuleActionDto) {
        super(data);
        (<any>this).actionType = "Algolia";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).appId = _data["appId"];
        (<any>this).apiKey = _data["apiKey"];
        (<any>this).indexName = _data["indexName"];
        (<any>this).document = _data["document"];
        (<any>this).delete = _data["delete"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AlgoliaRuleActionDto {
        const result = new AlgoliaRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["appId"] = this.appId;
        data["apiKey"] = this.apiKey;
        data["indexName"] = this.indexName;
        data["document"] = this.document;
        data["delete"] = this.delete;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAlgoliaRuleActionDto extends IRuleActionDto {
    readonly appId: string;
    readonly apiKey: string;
    readonly indexName: string;
    readonly document?: string | undefined;
    readonly delete?: string | undefined;
}

export class AzureQueueRuleActionDto extends RuleActionDto implements IAzureQueueRuleActionDto {
    readonly connectionString!: string;
    readonly queue!: string;
    readonly payload?: string | undefined;

    constructor(data?: IAzureQueueRuleActionDto) {
        super(data);
        (<any>this).actionType = "AzureQueue";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).connectionString = _data["connectionString"];
        (<any>this).queue = _data["queue"];
        (<any>this).payload = _data["payload"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AzureQueueRuleActionDto {
        const result = new AzureQueueRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["connectionString"] = this.connectionString;
        data["queue"] = this.queue;
        data["payload"] = this.payload;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAzureQueueRuleActionDto extends IRuleActionDto {
    readonly connectionString: string;
    readonly queue: string;
    readonly payload?: string | undefined;
}

export class CommentRuleActionDto extends RuleActionDto implements ICommentRuleActionDto {
    readonly text!: string;
    readonly client?: string | undefined;

    constructor(data?: ICommentRuleActionDto) {
        super(data);
        (<any>this).actionType = "Comment";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).text = _data["text"];
        (<any>this).client = _data["client"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CommentRuleActionDto {
        const result = new CommentRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["text"] = this.text;
        data["client"] = this.client;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ICommentRuleActionDto extends IRuleActionDto {
    readonly text: string;
    readonly client?: string | undefined;
}

export class CreateContentRuleActionDto extends RuleActionDto implements ICreateContentRuleActionDto {
    readonly data!: string;
    readonly schema!: string;
    readonly client?: string | undefined;
    readonly publish!: boolean;

    constructor(data?: ICreateContentRuleActionDto) {
        super(data);
        (<any>this).actionType = "CreateContent";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).data = _data["data"];
        (<any>this).schema = _data["schema"];
        (<any>this).client = _data["client"];
        (<any>this).publish = _data["publish"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateContentRuleActionDto {
        const result = new CreateContentRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["data"] = this.data;
        data["schema"] = this.schema;
        data["client"] = this.client;
        data["publish"] = this.publish;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ICreateContentRuleActionDto extends IRuleActionDto {
    readonly data: string;
    readonly schema: string;
    readonly client?: string | undefined;
    readonly publish: boolean;
}

export class DiscourseRuleActionDto extends RuleActionDto implements IDiscourseRuleActionDto {
    readonly url!: string;
    readonly apiKey!: string;
    readonly apiUsername!: string;
    readonly text!: string;
    readonly title?: string | undefined;
    readonly topic?: number | undefined;
    readonly category?: number | undefined;

    constructor(data?: IDiscourseRuleActionDto) {
        super(data);
        (<any>this).actionType = "Discourse";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).url = _data["url"];
        (<any>this).apiKey = _data["apiKey"];
        (<any>this).apiUsername = _data["apiUsername"];
        (<any>this).text = _data["text"];
        (<any>this).title = _data["title"];
        (<any>this).topic = _data["topic"];
        (<any>this).category = _data["category"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DiscourseRuleActionDto {
        const result = new DiscourseRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["url"] = this.url;
        data["apiKey"] = this.apiKey;
        data["apiUsername"] = this.apiUsername;
        data["text"] = this.text;
        data["title"] = this.title;
        data["topic"] = this.topic;
        data["category"] = this.category;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IDiscourseRuleActionDto extends IRuleActionDto {
    readonly url: string;
    readonly apiKey: string;
    readonly apiUsername: string;
    readonly text: string;
    readonly title?: string | undefined;
    readonly topic?: number | undefined;
    readonly category?: number | undefined;
}

export class ElasticSearchRuleActionDto extends RuleActionDto implements IElasticSearchRuleActionDto {
    readonly host!: string;
    readonly indexName!: string;
    readonly username?: string | undefined;
    readonly password?: string | undefined;
    readonly document?: string | undefined;
    readonly delete?: string | undefined;

    constructor(data?: IElasticSearchRuleActionDto) {
        super(data);
        (<any>this).actionType = "ElasticSearch";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).host = _data["host"];
        (<any>this).indexName = _data["indexName"];
        (<any>this).username = _data["username"];
        (<any>this).password = _data["password"];
        (<any>this).document = _data["document"];
        (<any>this).delete = _data["delete"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ElasticSearchRuleActionDto {
        const result = new ElasticSearchRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["host"] = this.host;
        data["indexName"] = this.indexName;
        data["username"] = this.username;
        data["password"] = this.password;
        data["document"] = this.document;
        data["delete"] = this.delete;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IElasticSearchRuleActionDto extends IRuleActionDto {
    readonly host: string;
    readonly indexName: string;
    readonly username?: string | undefined;
    readonly password?: string | undefined;
    readonly document?: string | undefined;
    readonly delete?: string | undefined;
}

export class EmailRuleActionDto extends RuleActionDto implements IEmailRuleActionDto {
    readonly serverHost!: string;
    readonly serverPort!: number;
    readonly messageFrom!: string;
    readonly messageTo!: string;
    readonly messageSubject!: string;
    readonly messageBody!: string;
    readonly serverUsername!: string;
    readonly serverPassword!: string;

    constructor(data?: IEmailRuleActionDto) {
        super(data);
        (<any>this).actionType = "Email";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).serverHost = _data["serverHost"];
        (<any>this).serverPort = _data["serverPort"];
        (<any>this).messageFrom = _data["messageFrom"];
        (<any>this).messageTo = _data["messageTo"];
        (<any>this).messageSubject = _data["messageSubject"];
        (<any>this).messageBody = _data["messageBody"];
        (<any>this).serverUsername = _data["serverUsername"];
        (<any>this).serverPassword = _data["serverPassword"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): EmailRuleActionDto {
        const result = new EmailRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["serverHost"] = this.serverHost;
        data["serverPort"] = this.serverPort;
        data["messageFrom"] = this.messageFrom;
        data["messageTo"] = this.messageTo;
        data["messageSubject"] = this.messageSubject;
        data["messageBody"] = this.messageBody;
        data["serverUsername"] = this.serverUsername;
        data["serverPassword"] = this.serverPassword;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IEmailRuleActionDto extends IRuleActionDto {
    readonly serverHost: string;
    readonly serverPort: number;
    readonly messageFrom: string;
    readonly messageTo: string;
    readonly messageSubject: string;
    readonly messageBody: string;
    readonly serverUsername: string;
    readonly serverPassword: string;
}

export class FastlyRuleActionDto extends RuleActionDto implements IFastlyRuleActionDto {
    readonly apiKey!: string;
    readonly serviceId!: string;

    constructor(data?: IFastlyRuleActionDto) {
        super(data);
        (<any>this).actionType = "Fastly";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).apiKey = _data["apiKey"];
        (<any>this).serviceId = _data["serviceId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FastlyRuleActionDto {
        const result = new FastlyRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["apiKey"] = this.apiKey;
        data["serviceId"] = this.serviceId;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IFastlyRuleActionDto extends IRuleActionDto {
    readonly apiKey: string;
    readonly serviceId: string;
}

export class MediumRuleActionDto extends RuleActionDto implements IMediumRuleActionDto {
    readonly accessToken!: string;
    readonly title!: string;
    readonly content!: string;
    readonly canonicalUrl?: string | undefined;
    readonly tags?: string | undefined;
    readonly publicationId?: string | undefined;
    readonly isHtml!: boolean;

    constructor(data?: IMediumRuleActionDto) {
        super(data);
        (<any>this).actionType = "Medium";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).accessToken = _data["accessToken"];
        (<any>this).title = _data["title"];
        (<any>this).content = _data["content"];
        (<any>this).canonicalUrl = _data["canonicalUrl"];
        (<any>this).tags = _data["tags"];
        (<any>this).publicationId = _data["publicationId"];
        (<any>this).isHtml = _data["isHtml"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): MediumRuleActionDto {
        const result = new MediumRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["accessToken"] = this.accessToken;
        data["title"] = this.title;
        data["content"] = this.content;
        data["canonicalUrl"] = this.canonicalUrl;
        data["tags"] = this.tags;
        data["publicationId"] = this.publicationId;
        data["isHtml"] = this.isHtml;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IMediumRuleActionDto extends IRuleActionDto {
    readonly accessToken: string;
    readonly title: string;
    readonly content: string;
    readonly canonicalUrl?: string | undefined;
    readonly tags?: string | undefined;
    readonly publicationId?: string | undefined;
    readonly isHtml: boolean;
}

export class NotificationRuleActionDto extends RuleActionDto implements INotificationRuleActionDto {
    readonly user!: string;
    readonly text!: string;
    readonly url?: string | undefined;
    readonly client?: string | undefined;

    constructor(data?: INotificationRuleActionDto) {
        super(data);
        (<any>this).actionType = "Notification";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).user = _data["user"];
        (<any>this).text = _data["text"];
        (<any>this).url = _data["url"];
        (<any>this).client = _data["client"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): NotificationRuleActionDto {
        const result = new NotificationRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["user"] = this.user;
        data["text"] = this.text;
        data["url"] = this.url;
        data["client"] = this.client;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface INotificationRuleActionDto extends IRuleActionDto {
    readonly user: string;
    readonly text: string;
    readonly url?: string | undefined;
    readonly client?: string | undefined;
}

export class OpenSearchRuleActionDto extends RuleActionDto implements IOpenSearchRuleActionDto {
    readonly host!: string;
    readonly indexName!: string;
    readonly username?: string | undefined;
    readonly password?: string | undefined;
    readonly document?: string | undefined;
    readonly delete?: string | undefined;

    constructor(data?: IOpenSearchRuleActionDto) {
        super(data);
        (<any>this).actionType = "OpenSearch";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).host = _data["host"];
        (<any>this).indexName = _data["indexName"];
        (<any>this).username = _data["username"];
        (<any>this).password = _data["password"];
        (<any>this).document = _data["document"];
        (<any>this).delete = _data["delete"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): OpenSearchRuleActionDto {
        const result = new OpenSearchRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["host"] = this.host;
        data["indexName"] = this.indexName;
        data["username"] = this.username;
        data["password"] = this.password;
        data["document"] = this.document;
        data["delete"] = this.delete;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IOpenSearchRuleActionDto extends IRuleActionDto {
    readonly host: string;
    readonly indexName: string;
    readonly username?: string | undefined;
    readonly password?: string | undefined;
    readonly document?: string | undefined;
    readonly delete?: string | undefined;
}

export class PrerenderRuleActionDto extends RuleActionDto implements IPrerenderRuleActionDto {
    readonly token!: string;
    readonly url!: string;

    constructor(data?: IPrerenderRuleActionDto) {
        super(data);
        (<any>this).actionType = "Prerender";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).token = _data["token"];
        (<any>this).url = _data["url"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): PrerenderRuleActionDto {
        const result = new PrerenderRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["token"] = this.token;
        data["url"] = this.url;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IPrerenderRuleActionDto extends IRuleActionDto {
    readonly token: string;
    readonly url: string;
}

export class ScriptRuleActionDto extends RuleActionDto implements IScriptRuleActionDto {
    readonly script!: string;

    constructor(data?: IScriptRuleActionDto) {
        super(data);
        (<any>this).actionType = "Script";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).script = _data["script"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ScriptRuleActionDto {
        const result = new ScriptRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["script"] = this.script;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IScriptRuleActionDto extends IRuleActionDto {
    readonly script: string;
}

export class SignalRRuleActionDto extends RuleActionDto implements ISignalRRuleActionDto {
    readonly connectionString!: string;
    readonly hubName!: string;
    readonly action!: SignalRActionType;
    readonly methodName?: string | undefined;
    readonly target?: string | undefined;
    readonly payload?: string | undefined;

    constructor(data?: ISignalRRuleActionDto) {
        super(data);
        (<any>this).actionType = "SignalR";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).connectionString = _data["connectionString"];
        (<any>this).hubName = _data["hubName"];
        (<any>this).action = _data["action"];
        (<any>this).methodName = _data["methodName"];
        (<any>this).target = _data["target"];
        (<any>this).payload = _data["payload"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SignalRRuleActionDto {
        const result = new SignalRRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["connectionString"] = this.connectionString;
        data["hubName"] = this.hubName;
        data["action"] = this.action;
        data["methodName"] = this.methodName;
        data["target"] = this.target;
        data["payload"] = this.payload;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISignalRRuleActionDto extends IRuleActionDto {
    readonly connectionString: string;
    readonly hubName: string;
    readonly action: SignalRActionType;
    readonly methodName?: string | undefined;
    readonly target?: string | undefined;
    readonly payload?: string | undefined;
}

export class SlackRuleActionDto extends RuleActionDto implements ISlackRuleActionDto {
    readonly webhookUrl!: string;
    readonly text!: string;

    constructor(data?: ISlackRuleActionDto) {
        super(data);
        (<any>this).actionType = "Slack";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).webhookUrl = _data["webhookUrl"];
        (<any>this).text = _data["text"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SlackRuleActionDto {
        const result = new SlackRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["webhookUrl"] = this.webhookUrl;
        data["text"] = this.text;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISlackRuleActionDto extends IRuleActionDto {
    readonly webhookUrl: string;
    readonly text: string;
}

export class TweetRuleActionDto extends RuleActionDto implements ITweetRuleActionDto {
    readonly accessToken!: string;
    readonly accessSecret!: string;
    readonly text!: string;

    constructor(data?: ITweetRuleActionDto) {
        super(data);
        (<any>this).actionType = "Tweet";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).accessToken = _data["accessToken"];
        (<any>this).accessSecret = _data["accessSecret"];
        (<any>this).text = _data["text"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TweetRuleActionDto {
        const result = new TweetRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["accessToken"] = this.accessToken;
        data["accessSecret"] = this.accessSecret;
        data["text"] = this.text;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ITweetRuleActionDto extends IRuleActionDto {
    readonly accessToken: string;
    readonly accessSecret: string;
    readonly text: string;
}

export class TypesenseRuleActionDto extends RuleActionDto implements ITypesenseRuleActionDto {
    readonly host!: string;
    readonly indexName!: string;
    readonly apiKey!: string;
    readonly document?: string | undefined;
    readonly delete?: string | undefined;

    constructor(data?: ITypesenseRuleActionDto) {
        super(data);
        (<any>this).actionType = "Typesense";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).host = _data["host"];
        (<any>this).indexName = _data["indexName"];
        (<any>this).apiKey = _data["apiKey"];
        (<any>this).document = _data["document"];
        (<any>this).delete = _data["delete"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TypesenseRuleActionDto {
        const result = new TypesenseRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["host"] = this.host;
        data["indexName"] = this.indexName;
        data["apiKey"] = this.apiKey;
        data["document"] = this.document;
        data["delete"] = this.delete;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ITypesenseRuleActionDto extends IRuleActionDto {
    readonly host: string;
    readonly indexName: string;
    readonly apiKey: string;
    readonly document?: string | undefined;
    readonly delete?: string | undefined;
}

export class WebhookRuleActionDto extends RuleActionDto implements IWebhookRuleActionDto {
    readonly url!: string;
    readonly method!: WebhookMethod;
    readonly payload?: string | undefined;
    readonly payloadType?: string | undefined;
    readonly headers?: string | undefined;
    readonly sharedSecret?: string | undefined;

    constructor(data?: IWebhookRuleActionDto) {
        super(data);
        (<any>this).actionType = "Webhook";
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).url = _data["url"];
        (<any>this).method = _data["method"];
        (<any>this).payload = _data["payload"];
        (<any>this).payloadType = _data["payloadType"];
        (<any>this).headers = _data["headers"];
        (<any>this).sharedSecret = _data["sharedSecret"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): WebhookRuleActionDto {
        const result = new WebhookRuleActionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["url"] = this.url;
        data["method"] = this.method;
        data["payload"] = this.payload;
        data["payloadType"] = this.payloadType;
        data["headers"] = this.headers;
        data["sharedSecret"] = this.sharedSecret;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IWebhookRuleActionDto extends IRuleActionDto {
    readonly url: string;
    readonly method: WebhookMethod;
    readonly payload?: string | undefined;
    readonly payloadType?: string | undefined;
    readonly headers?: string | undefined;
    readonly sharedSecret?: string | undefined;
}

export class CreateRuleDto implements ICreateRuleDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger!: RuleTriggerDto;
    /** The action properties. */
    readonly action?: RuleActionDto | undefined;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow!: FlowDefinitionDto;
    /** Enable or disable the rule. */
    readonly isEnabled?: boolean | undefined;

    constructor(data?: ICreateRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).trigger = _data["trigger"] ? RuleTriggerDto.fromJSON(_data["trigger"]) : <any>undefined;
        (<any>this).action = _data["action"] ? RuleActionDto.fromJSON(_data["action"]) : <any>undefined;
        (<any>this).flow = _data["flow"] ? FlowDefinitionDto.fromJSON(_data["flow"]) : new FlowDefinitionDto();
        (<any>this).isEnabled = _data["isEnabled"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateRuleDto {
        const result = new CreateRuleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["trigger"] = this.trigger ? this.trigger.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["flow"] = this.flow ? this.flow.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICreateRuleDto {
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger: RuleTriggerDto;
    /** The action properties. */
    readonly action?: RuleActionDto | undefined;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow: FlowDefinitionDto;
    /** Enable or disable the rule. */
    readonly isEnabled?: boolean | undefined;
}

export class UpdateRuleDto implements IUpdateRuleDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger?: RuleTriggerDto | undefined;
    /** The flow to describe the sequence of actions to perform. */
    readonly action?: RuleActionDto | undefined;
    /** The flow. */
    readonly flow?: FlowDefinitionDto | undefined;
    /** Enable or disable the rule. */
    readonly isEnabled?: boolean | undefined;

    constructor(data?: IUpdateRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).trigger = _data["trigger"] ? RuleTriggerDto.fromJSON(_data["trigger"]) : <any>undefined;
        (<any>this).action = _data["action"] ? RuleActionDto.fromJSON(_data["action"]) : <any>undefined;
        (<any>this).flow = _data["flow"] ? FlowDefinitionDto.fromJSON(_data["flow"]) : <any>undefined;
        (<any>this).isEnabled = _data["isEnabled"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateRuleDto {
        const result = new UpdateRuleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["trigger"] = this.trigger ? this.trigger.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["flow"] = this.flow ? this.flow.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateRuleDto {
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger?: RuleTriggerDto | undefined;
    /** The flow to describe the sequence of actions to perform. */
    readonly action?: RuleActionDto | undefined;
    /** The flow. */
    readonly flow?: FlowDefinitionDto | undefined;
    /** Enable or disable the rule. */
    readonly isEnabled?: boolean | undefined;
}

export class SimulatedRuleEventsDto extends ResourceDto implements ISimulatedRuleEventsDto {
    /** The total number of simulated rule events. */
    readonly total!: number;
    /** The simulated rule events. */
    readonly items!: SimulatedRuleEventDto[];

    constructor(data?: ISimulatedRuleEventsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).total = _data["total"];
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(SimulatedRuleEventDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SimulatedRuleEventsDto {
        const result = new SimulatedRuleEventsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface ISimulatedRuleEventsDto extends IResourceDto {
    /** The total number of simulated rule events. */
    readonly total: number;
    /** The simulated rule events. */
    readonly items: SimulatedRuleEventDto[];
}

export class SimulatedRuleEventDto implements ISimulatedRuleEventDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The unique event id. */
    readonly eventId!: string;
    /** The the unique id of the simulated event. */
    readonly uniqueId!: string;
    /** The name of the event. */
    readonly eventName!: string;
    /** The source event. */
    readonly event!: any;
    /** The enriched event. */
    readonly enrichedEvent?: any | undefined;
    /** The flow state. */
    readonly flowState?: FlowExecutionStateDto | undefined;
    /** The reason why the event has been skipped. */
    readonly skipReasons!: SkipReason[];

    constructor(data?: ISimulatedRuleEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).eventId = _data["eventId"];
        (<any>this).uniqueId = _data["uniqueId"];
        (<any>this).eventName = _data["eventName"];
        (<any>this).event = _data["event"];
        (<any>this).enrichedEvent = _data["enrichedEvent"];
        (<any>this).flowState = _data["flowState"] ? FlowExecutionStateDto.fromJSON(_data["flowState"]) : <any>undefined;
        if (Array.isArray(_data["skipReasons"])) {
            (<any>this).skipReasons = [] as any;
            for (let item of _data["skipReasons"])
                (<any>this).skipReasons!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SimulatedRuleEventDto {
        const result = new SimulatedRuleEventDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["eventId"] = this.eventId;
        data["uniqueId"] = this.uniqueId;
        data["eventName"] = this.eventName;
        data["event"] = this.event;
        data["enrichedEvent"] = this.enrichedEvent;
        data["flowState"] = this.flowState ? this.flowState.toJSON() : <any>undefined;
        if (Array.isArray(this.skipReasons)) {
            data["skipReasons"] = [];
            for (let item of this.skipReasons)
                data["skipReasons"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ISimulatedRuleEventDto {
    /** The unique event id. */
    readonly eventId: string;
    /** The the unique id of the simulated event. */
    readonly uniqueId: string;
    /** The name of the event. */
    readonly eventName: string;
    /** The source event. */
    readonly event: any;
    /** The enriched event. */
    readonly enrichedEvent?: any | undefined;
    /** The flow state. */
    readonly flowState?: FlowExecutionStateDto | undefined;
    /** The reason why the event has been skipped. */
    readonly skipReasons: SkipReason[];
}

export class FlowExecutionStateDto implements IFlowExecutionStateDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The actual definition of the the steps to be executed. */
    readonly definition!: FlowDefinitionDto;
    /** The context. */
    readonly context!: any;
    /** The description of the execution state (usually the event name). */
    readonly description!: string;
    /** The state of each step. */
    readonly steps!: { [key: string]: FlowExecutionStepStateDto; };
    /** The next step to be executed. */
    readonly nextStepId!: string;
    /** THe time when the next step will be executed. */
    readonly nextRun?: DateTime | undefined;
    /** The creation time. */
    readonly created!: DateTime;
    /** The completion time. */
    readonly completed!: DateTime;
    /** The overall status. */
    readonly status!: FlowExecutionStatus;

    constructor(data?: IFlowExecutionStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).definition = _data["definition"] ? FlowDefinitionDto.fromJSON(_data["definition"]) : new FlowDefinitionDto();
        (<any>this).context = _data["context"];
        (<any>this).description = _data["description"];
        if (_data["steps"]) {
            (<any>this).steps = {} as any;
            for (let key in _data["steps"]) {
                if (_data["steps"].hasOwnProperty(key))
                    (<any>(<any>this).steps)![key] = _data["steps"][key] ? FlowExecutionStepStateDto.fromJSON(_data["steps"][key]) : new FlowExecutionStepStateDto();
            }
        }
        (<any>this).nextStepId = _data["nextStepId"];
        (<any>this).nextRun = _data["nextRun"] ? DateTime.parseISO(_data["nextRun"].toString()) : <any>undefined;
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).completed = _data["completed"] ? DateTime.parseISO(_data["completed"].toString()) : <any>undefined;
        (<any>this).status = _data["status"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FlowExecutionStateDto {
        const result = new FlowExecutionStateDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["definition"] = this.definition ? this.definition.toJSON() : <any>undefined;
        data["context"] = this.context;
        data["description"] = this.description;
        if (this.steps) {
            data["steps"] = {};
            for (let key in this.steps) {
                if (this.steps.hasOwnProperty(key))
                    (<any>data["steps"])[key] = this.steps[key] ? this.steps[key].toJSON() : <any>undefined;
            }
        }
        data["nextStepId"] = this.nextStepId;
        data["nextRun"] = this.nextRun ? this.nextRun.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["status"] = this.status;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFlowExecutionStateDto {
    /** The actual definition of the the steps to be executed. */
    readonly definition: FlowDefinitionDto;
    /** The context. */
    readonly context: any;
    /** The description of the execution state (usually the event name). */
    readonly description: string;
    /** The state of each step. */
    readonly steps: { [key: string]: FlowExecutionStepStateDto; };
    /** The next step to be executed. */
    readonly nextStepId: string;
    /** THe time when the next step will be executed. */
    readonly nextRun?: DateTime | undefined;
    /** The creation time. */
    readonly created: DateTime;
    /** The completion time. */
    readonly completed: DateTime;
    /** The overall status. */
    readonly status: FlowExecutionStatus;
}

export class FlowExecutionStepStateDto implements IFlowExecutionStepStateDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The status of this step. */
    readonly status!: FlowExecutionStatus;
    /** The different attempts. */
    readonly attempts!: FlowExecutionStepAttemptDto[];

    constructor(data?: IFlowExecutionStepStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).status = _data["status"];
        if (Array.isArray(_data["attempts"])) {
            (<any>this).attempts = [] as any;
            for (let item of _data["attempts"])
                (<any>this).attempts!.push(FlowExecutionStepAttemptDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FlowExecutionStepStateDto {
        const result = new FlowExecutionStepStateDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["status"] = this.status;
        if (Array.isArray(this.attempts)) {
            data["attempts"] = [];
            for (let item of this.attempts)
                data["attempts"].push(item.toJSON());
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFlowExecutionStepStateDto {
    /** The status of this step. */
    readonly status: FlowExecutionStatus;
    /** The different attempts. */
    readonly attempts: FlowExecutionStepAttemptDto[];
}

export type FlowExecutionStatus = "Pending" | "Scheduled" | "Completed" | "Failed" | "Running";

export const FlowExecutionStatusValues: ReadonlyArray<FlowExecutionStatus> = [
	"Pending",
	"Scheduled",
	"Completed",
	"Failed",
	"Running"
];

export class FlowExecutionStepAttemptDto implements IFlowExecutionStepAttemptDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The log messages. */
    readonly log!: FlowExecutionStepLogEntryDto[];
    /** The time when the attempt has been started. */
    readonly started!: DateTime;
    /** The time when the attempt has been completed. */
    readonly completed!: DateTime;
    /** The error, if there is any. */
    readonly error?: string | undefined;

    constructor(data?: IFlowExecutionStepAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["log"])) {
            (<any>this).log = [] as any;
            for (let item of _data["log"])
                (<any>this).log!.push(FlowExecutionStepLogEntryDto.fromJSON(item));
        }
        (<any>this).started = _data["started"] ? DateTime.parseISO(_data["started"].toString()) : <any>undefined;
        (<any>this).completed = _data["completed"] ? DateTime.parseISO(_data["completed"].toString()) : <any>undefined;
        (<any>this).error = _data["error"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FlowExecutionStepAttemptDto {
        const result = new FlowExecutionStepAttemptDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.log)) {
            data["log"] = [];
            for (let item of this.log)
                data["log"].push(item.toJSON());
        }
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["error"] = this.error;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFlowExecutionStepAttemptDto {
    /** The log messages. */
    readonly log: FlowExecutionStepLogEntryDto[];
    /** The time when the attempt has been started. */
    readonly started: DateTime;
    /** The time when the attempt has been completed. */
    readonly completed: DateTime;
    /** The error, if there is any. */
    readonly error?: string | undefined;
}

export class FlowExecutionStepLogEntryDto implements IFlowExecutionStepLogEntryDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The timestamp. */
    readonly timestamp!: DateTime;
    /** The log message. */
    readonly message!: string;
    /** A detailed dump. */
    readonly dump?: string | undefined;

    constructor(data?: IFlowExecutionStepLogEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).timestamp = _data["timestamp"] ? DateTime.parseISO(_data["timestamp"].toString()) : <any>undefined;
        (<any>this).message = _data["message"];
        (<any>this).dump = _data["dump"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FlowExecutionStepLogEntryDto {
        const result = new FlowExecutionStepLogEntryDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["message"] = this.message;
        data["dump"] = this.dump;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFlowExecutionStepLogEntryDto {
    /** The timestamp. */
    readonly timestamp: DateTime;
    /** The log message. */
    readonly message: string;
    /** A detailed dump. */
    readonly dump?: string | undefined;
}

export type SkipReason = "None" | "ConditionDoesNotMatch" | "ConditionPrecheckDoesNotMatch" | "Disabled" | "Failed" | "FromRule" | "NoTrigger" | "TooOld" | "WrongEvent" | "WrongEventForTrigger";

export const SkipReasonValues: ReadonlyArray<SkipReason> = [
	"None",
	"ConditionDoesNotMatch",
	"ConditionPrecheckDoesNotMatch",
	"Disabled",
	"Failed",
	"FromRule",
	"NoTrigger",
	"TooOld",
	"WrongEvent",
	"WrongEventForTrigger"
];

export class RuleEventsDto extends ResourceDto implements IRuleEventsDto {
    /** The total number of rule events. */
    readonly total!: number;
    /** The rule events. */
    readonly items!: RuleEventDto[];

    get canCancelAll() {
        return this.compute('canCancelAll ', () => hasAnyLink(this._links, 'cancel'));
    }

    constructor(data?: IRuleEventsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).total = _data["total"];
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(RuleEventDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RuleEventsDto {
        const result = new RuleEventsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IRuleEventsDto extends IResourceDto {
    /** The total number of rule events. */
    readonly total: number;
    /** The rule events. */
    readonly items: RuleEventDto[];
}

export class RuleEventDto extends ResourceDto implements IRuleEventDto {
    /** The ID of the event. */
    readonly id!: string;
    /** The flow state. */
    readonly flowState!: FlowExecutionStateDto;

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'cancel'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IRuleEventDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).flowState = _data["flowState"] ? FlowExecutionStateDto.fromJSON(_data["flowState"]) : new FlowExecutionStateDto();
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RuleEventDto {
        const result = new RuleEventDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["flowState"] = this.flowState ? this.flowState.toJSON() : <any>undefined;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IRuleEventDto extends IResourceDto {
    /** The ID of the event. */
    readonly id: string;
    /** The flow state. */
    readonly flowState: FlowExecutionStateDto;
}

export class PlansDto implements IPlansDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The available plans. */
    readonly plans!: PlanDto[];
    /** The current plan id. */
    readonly currentPlanId?: string | undefined;
    /** The plan owner. */
    readonly planOwner?: string | undefined;
    /** The link to the management portal. */
    readonly portalLink?: string | undefined;
    /** The referral management. */
    readonly referral?: ReferralInfoDto | undefined;
    /** The reason why the plan cannot be changed. */
    readonly locked!: PlansLockedReason;

    constructor(data?: IPlansDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["plans"])) {
            (<any>this).plans = [] as any;
            for (let item of _data["plans"])
                (<any>this).plans!.push(PlanDto.fromJSON(item));
        }
        (<any>this).currentPlanId = _data["currentPlanId"];
        (<any>this).planOwner = _data["planOwner"];
        (<any>this).portalLink = _data["portalLink"];
        (<any>this).referral = _data["referral"] ? ReferralInfoDto.fromJSON(_data["referral"]) : <any>undefined;
        (<any>this).locked = _data["locked"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): PlansDto {
        const result = new PlansDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.plans)) {
            data["plans"] = [];
            for (let item of this.plans)
                data["plans"].push(item.toJSON());
        }
        data["currentPlanId"] = this.currentPlanId;
        data["planOwner"] = this.planOwner;
        data["portalLink"] = this.portalLink;
        data["referral"] = this.referral ? this.referral.toJSON() : <any>undefined;
        data["locked"] = this.locked;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IPlansDto {
    /** The available plans. */
    readonly plans: PlanDto[];
    /** The current plan id. */
    readonly currentPlanId?: string | undefined;
    /** The plan owner. */
    readonly planOwner?: string | undefined;
    /** The link to the management portal. */
    readonly portalLink?: string | undefined;
    /** The referral management. */
    readonly referral?: ReferralInfoDto | undefined;
    /** The reason why the plan cannot be changed. */
    readonly locked: PlansLockedReason;
}

export class PlanDto implements IPlanDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The ID of the plan. */
    readonly id!: string;
    /** The name of the plan. */
    readonly name!: string;
    /** The monthly costs of the plan. */
    readonly costs!: string;
    /** An optional confirm text for the monthly subscription. */
    readonly confirmText?: string | undefined;
    /** An optional confirm text for the yearly subscription. */
    readonly yearlyConfirmText?: string | undefined;
    /** The yearly costs of the plan. */
    readonly yearlyCosts?: string | undefined;
    /** The yearly ID of the plan. */
    readonly yearlyId?: string | undefined;
    /** The maximum number of API traffic. */
    readonly maxApiBytes!: number;
    /** The maximum number of API calls. */
    readonly maxApiCalls!: number;
    /** The maximum allowed asset size. */
    readonly maxAssetSize!: number;
    /** The maximum number of contributors. */
    readonly maxContributors!: number;

    constructor(data?: IPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).id = _data["id"];
        (<any>this).name = _data["name"];
        (<any>this).costs = _data["costs"];
        (<any>this).confirmText = _data["confirmText"];
        (<any>this).yearlyConfirmText = _data["yearlyConfirmText"];
        (<any>this).yearlyCosts = _data["yearlyCosts"];
        (<any>this).yearlyId = _data["yearlyId"];
        (<any>this).maxApiBytes = _data["maxApiBytes"];
        (<any>this).maxApiCalls = _data["maxApiCalls"];
        (<any>this).maxAssetSize = _data["maxAssetSize"];
        (<any>this).maxContributors = _data["maxContributors"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): PlanDto {
        const result = new PlanDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["name"] = this.name;
        data["costs"] = this.costs;
        data["confirmText"] = this.confirmText;
        data["yearlyConfirmText"] = this.yearlyConfirmText;
        data["yearlyCosts"] = this.yearlyCosts;
        data["yearlyId"] = this.yearlyId;
        data["maxApiBytes"] = this.maxApiBytes;
        data["maxApiCalls"] = this.maxApiCalls;
        data["maxAssetSize"] = this.maxAssetSize;
        data["maxContributors"] = this.maxContributors;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IPlanDto {
    /** The ID of the plan. */
    readonly id: string;
    /** The name of the plan. */
    readonly name: string;
    /** The monthly costs of the plan. */
    readonly costs: string;
    /** An optional confirm text for the monthly subscription. */
    readonly confirmText?: string | undefined;
    /** An optional confirm text for the yearly subscription. */
    readonly yearlyConfirmText?: string | undefined;
    /** The yearly costs of the plan. */
    readonly yearlyCosts?: string | undefined;
    /** The yearly ID of the plan. */
    readonly yearlyId?: string | undefined;
    /** The maximum number of API traffic. */
    readonly maxApiBytes: number;
    /** The maximum number of API calls. */
    readonly maxApiCalls: number;
    /** The maximum allowed asset size. */
    readonly maxAssetSize: number;
    /** The maximum number of contributors. */
    readonly maxContributors: number;
}

export class ReferralInfoDto implements IReferralInfoDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    readonly code!: string;
    readonly earned!: string;
    readonly condition!: string;

    constructor(data?: IReferralInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).code = _data["code"];
        (<any>this).earned = _data["earned"];
        (<any>this).condition = _data["condition"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ReferralInfoDto {
        const result = new ReferralInfoDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["code"] = this.code;
        data["earned"] = this.earned;
        data["condition"] = this.condition;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IReferralInfoDto {
    readonly code: string;
    readonly earned: string;
    readonly condition: string;
}

export type PlansLockedReason = "None" | "NotOwner" | "NoPermission" | "ManagedByTeam";

export const PlansLockedReasonValues: ReadonlyArray<PlansLockedReason> = [
	"None",
	"NotOwner",
	"NoPermission",
	"ManagedByTeam"
];

export class PlanChangedDto implements IPlanChangedDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Optional redirect uri. */
    readonly redirectUri?: string | undefined;

    constructor(data?: IPlanChangedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).redirectUri = _data["redirectUri"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): PlanChangedDto {
        const result = new PlanChangedDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["redirectUri"] = this.redirectUri;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IPlanChangedDto {
    /** Optional redirect uri. */
    readonly redirectUri?: string | undefined;
}

export class ChangePlanDto implements IChangePlanDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The new plan id. */
    readonly planId!: string;

    constructor(data?: IChangePlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).planId = _data["planId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ChangePlanDto {
        const result = new ChangePlanDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["planId"] = this.planId;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IChangePlanDto {
    /** The new plan id. */
    readonly planId: string;
}

export class FeaturesDto implements IFeaturesDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The latest features. */
    readonly features!: FeatureDto[];
    /** The recent version. */
    readonly version!: number;

    constructor(data?: IFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["features"])) {
            (<any>this).features = [] as any;
            for (let item of _data["features"])
                (<any>this).features!.push(FeatureDto.fromJSON(item));
        }
        (<any>this).version = _data["version"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FeaturesDto {
        const result = new FeaturesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        data["version"] = this.version;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFeaturesDto {
    /** The latest features. */
    readonly features: FeatureDto[];
    /** The recent version. */
    readonly version: number;
}

export class FeatureDto implements IFeatureDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the feature. */
    readonly name!: string;
    /** The description text. */
    readonly text!: string;

    constructor(data?: IFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).text = _data["text"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): FeatureDto {
        const result = new FeatureDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["text"] = this.text;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IFeatureDto {
    /** The name of the feature. */
    readonly name: string;
    /** The description text. */
    readonly text: string;
}

export class LanguageDto implements ILanguageDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The iso code of the language. */
    readonly iso2Code!: string;
    /** The english name of the language. */
    readonly englishName!: string;

    constructor(data?: ILanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).iso2Code = _data["iso2Code"];
        (<any>this).englishName = _data["englishName"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): LanguageDto {
        const result = new LanguageDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["iso2Code"] = this.iso2Code;
        data["englishName"] = this.englishName;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ILanguageDto {
    /** The iso code of the language. */
    readonly iso2Code: string;
    /** The english name of the language. */
    readonly englishName: string;
}

export class JobsDto extends ResourceDto implements IJobsDto {
    /** The jobs. */
    readonly items!: JobDto[];

    get canCreateBackup() {
        return this.compute('canCreateBackup', () => hasAnyLink(this._links, 'create/backups'));
    }

    constructor(data?: IJobsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(JobDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): JobsDto {
        const result = new JobsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IJobsDto extends IResourceDto {
    /** The jobs. */
    readonly items: JobDto[];
}

export class JobDto extends ResourceDto implements IJobDto {
    /** The ID of the job. */
    readonly id!: string;
    /** The time when the job has been started. */
    readonly started!: DateTime;
    /** The time when the job has been stopped. */
    readonly stopped?: DateTime | undefined;
    /** The status of the operation. */
    readonly status!: JobStatus;
    /** The name of the task. */
    readonly taskName!: string;
    /** The description of the job. */
    readonly description!: string;
    /** The arguments for the job. */
    readonly taskArguments!: { [key: string]: string; };
    /** The list of log items. */
    readonly log!: JobLogMessageDto[];
    /** Indicates whether the job can be downloaded. */
    readonly canDownload!: boolean;

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canDownloadUrl() {
        return this.compute('canDownloadUrl', () => hasAnyLink(this._links, 'download'));
    }

    get downloadUrl() {
        return this.compute('downloadUrl', () => this._links['download']?.href);
    }

    get isfailed() {
        return this.status === 'Failed';
    }

    constructor(data?: IJobDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).started = _data["started"] ? DateTime.parseISO(_data["started"].toString()) : <any>undefined;
        (<any>this).stopped = _data["stopped"] ? DateTime.parseISO(_data["stopped"].toString()) : <any>undefined;
        (<any>this).status = _data["status"];
        (<any>this).taskName = _data["taskName"];
        (<any>this).description = _data["description"];
        if (_data["taskArguments"]) {
            (<any>this).taskArguments = {} as any;
            for (let key in _data["taskArguments"]) {
                if (_data["taskArguments"].hasOwnProperty(key))
                    (<any>(<any>this).taskArguments)![key] = _data["taskArguments"][key];
            }
        }
        if (Array.isArray(_data["log"])) {
            (<any>this).log = [] as any;
            for (let item of _data["log"])
                (<any>this).log!.push(JobLogMessageDto.fromJSON(item));
        }
        (<any>this).canDownload = _data["canDownload"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): JobDto {
        const result = new JobDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["stopped"] = this.stopped ? this.stopped.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["taskName"] = this.taskName;
        data["description"] = this.description;
        if (this.taskArguments) {
            data["taskArguments"] = {};
            for (let key in this.taskArguments) {
                if (this.taskArguments.hasOwnProperty(key))
                    (<any>data["taskArguments"])[key] = (<any>this.taskArguments)[key];
            }
        }
        if (Array.isArray(this.log)) {
            data["log"] = [];
            for (let item of this.log)
                data["log"].push(item.toJSON());
        }
        data["canDownload"] = this.canDownload;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IJobDto extends IResourceDto {
    /** The ID of the job. */
    readonly id: string;
    /** The time when the job has been started. */
    readonly started: DateTime;
    /** The time when the job has been stopped. */
    readonly stopped?: DateTime | undefined;
    /** The status of the operation. */
    readonly status: JobStatus;
    /** The name of the task. */
    readonly taskName: string;
    /** The description of the job. */
    readonly description: string;
    /** The arguments for the job. */
    readonly taskArguments: { [key: string]: string; };
    /** The list of log items. */
    readonly log: JobLogMessageDto[];
    /** Indicates whether the job can be downloaded. */
    readonly canDownload: boolean;
}

export type JobStatus = "Created" | "Started" | "Completed" | "Cancelled" | "Failed";

export const JobStatusValues: ReadonlyArray<JobStatus> = [
	"Created",
	"Started",
	"Completed",
	"Cancelled",
	"Failed"
];

export class JobLogMessageDto implements IJobLogMessageDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The timestamp. */
    readonly timestamp!: DateTime;
    /** The log message. */
    readonly message!: string;

    constructor(data?: IJobLogMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).timestamp = _data["timestamp"] ? DateTime.parseISO(_data["timestamp"].toString()) : <any>undefined;
        (<any>this).message = _data["message"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): JobLogMessageDto {
        const result = new JobLogMessageDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["message"] = this.message;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IJobLogMessageDto {
    /** The timestamp. */
    readonly timestamp: DateTime;
    /** The log message. */
    readonly message: string;
}

export class HistoryEventDto implements IHistoryEventDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The message for the event. */
    readonly message!: string;
    /** The type of the original event. */
    readonly eventType!: string;
    /** The user who called the action. */
    readonly actor!: string;
    /** Gets a unique id for the event. */
    readonly eventId!: string;
    /** The time when the event happened. */
    readonly created!: DateTime;
    /** The version identifier. */
    readonly version!: number;

    constructor(data?: IHistoryEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).message = _data["message"];
        (<any>this).eventType = _data["eventType"];
        (<any>this).actor = _data["actor"];
        (<any>this).eventId = _data["eventId"];
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).version = _data["version"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): HistoryEventDto {
        const result = new HistoryEventDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["message"] = this.message;
        data["eventType"] = this.eventType;
        data["actor"] = this.actor;
        data["eventId"] = this.eventId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["version"] = this.version;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IHistoryEventDto {
    /** The message for the event. */
    readonly message: string;
    /** The type of the original event. */
    readonly eventType: string;
    /** The user who called the action. */
    readonly actor: string;
    /** Gets a unique id for the event. */
    readonly eventId: string;
    /** The time when the event happened. */
    readonly created: DateTime;
    /** The version identifier. */
    readonly version: number;
}

export class EventConsumersDto extends ResourceDto implements IEventConsumersDto {
    /** The event consumers. */
    readonly items!: EventConsumerDto[];

    constructor(data?: IEventConsumersDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(EventConsumerDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): EventConsumersDto {
        const result = new EventConsumersDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IEventConsumersDto extends IResourceDto {
    /** The event consumers. */
    readonly items: EventConsumerDto[];
}

export class EventConsumerDto extends ResourceDto implements IEventConsumerDto {
    /** Indicates if the event consumer has been started. */
    readonly isStopped!: boolean;
    /** Indicates if the event consumer is resetting at the moment. */
    readonly isResetting!: boolean;
    /** The number of handled events. */
    readonly count!: number;
    /** The name of the event consumer. */
    readonly name!: string;
    /** The error details if the event consumer has been stopped after a failure. */
    readonly error?: string | undefined;
    /** The position within the vent stream. */
    readonly position?: string | undefined;

    get canReset() {
        return this.compute('reset', () => hasAnyLink(this._links, 'reset'));
    }

    get canStart() {
        return this.compute('canStart', () => hasAnyLink(this._links, 'start'));
    }

    get canStop() {
        return this.compute('canStop', () => hasAnyLink(this._links, 'stop'));
    }

    constructor(data?: IEventConsumerDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).isStopped = _data["isStopped"];
        (<any>this).isResetting = _data["isResetting"];
        (<any>this).count = _data["count"];
        (<any>this).name = _data["name"];
        (<any>this).error = _data["error"];
        (<any>this).position = _data["position"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): EventConsumerDto {
        const result = new EventConsumerDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["isStopped"] = this.isStopped;
        data["isResetting"] = this.isResetting;
        data["count"] = this.count;
        data["name"] = this.name;
        data["error"] = this.error;
        data["position"] = this.position;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IEventConsumerDto extends IResourceDto {
    /** Indicates if the event consumer has been started. */
    readonly isStopped: boolean;
    /** Indicates if the event consumer is resetting at the moment. */
    readonly isResetting: boolean;
    /** The number of handled events. */
    readonly count: number;
    /** The name of the event consumer. */
    readonly name: string;
    /** The error details if the event consumer has been stopped after a failure. */
    readonly error?: string | undefined;
    /** The position within the vent stream. */
    readonly position?: string | undefined;
}

export class ContentsDto extends ResourceDto implements IContentsDto {
    /** The total number of content items. */
    readonly total!: number;
    /** The content items. */
    readonly items!: ContentDto[];
    /** The possible statuses. */
    readonly statuses!: StatusInfoDto[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    get canCreateAndPublish() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create/publish'));
    }

    constructor(data?: IContentsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).total = _data["total"];
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(ContentDto.fromJSON(item));
        }
        if (Array.isArray(_data["statuses"])) {
            (<any>this).statuses = [] as any;
            for (let item of _data["statuses"])
                (<any>this).statuses!.push(StatusInfoDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ContentsDto {
        const result = new ContentsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IContentsDto extends IResourceDto {
    /** The total number of content items. */
    readonly total: number;
    /** The content items. */
    readonly items: ContentDto[];
    /** The possible statuses. */
    readonly statuses: StatusInfoDto[];
}

export class ContentDto extends ResourceDto implements IContentDto {
    /** The if of the content item. */
    readonly id!: string;
    /** The user that has created the content item. */
    readonly createdBy!: string;
    /** The user that has updated the content item. */
    readonly lastModifiedBy!: string;
    /** The data of the content item. */
    readonly data!: any;
    /** The reference data for the frontend UI. */
    readonly referenceData?: { [key: string]: { [key: string]: any; }; } | undefined;
    /** The date and time when the content item has been created. */
    readonly created!: DateTime;
    /** The date and time when the content item has been modified last. */
    readonly lastModified!: DateTime;
    /** The status of the content. */
    readonly status!: string;
    /** The new status of the content. */
    readonly newStatus?: string | undefined;
    /** The color of the status. */
    readonly statusColor!: string;
    /** The color of the new status. */
    readonly newStatusColor?: string | undefined;
    /** The UI token. */
    readonly editToken?: string | undefined;
    /** The scheduled status. */
    readonly scheduleJob?: ScheduleJobDto | undefined;
    /** The ID of the schema. */
    readonly schemaId!: string;
    /** The name of the schema. */
    readonly schemaName!: string;
    /** The display name of the schema. */
    readonly schemaDisplayName!: string;
    /** The reference fields. */
    readonly referenceFields!: FieldDto[];
    /** Indicates whether the content is deleted. */
    readonly isDeleted!: boolean;
    /** The version of the content. */
    readonly version!: number;

    get canPublish() {
        return this.compute('canPublish', () => this.statusUpdates.find(x => x.status === 'Published'));
    }

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'update'));
    }

    get canDraftCreate() {
        return this.compute('canDraftCreate', () => hasAnyLink(this._links, 'draft/create'));
    }

    get canDraftDelete() {
        return this.compute('canDraftDelete', () => hasAnyLink(this._links, 'draft/delete'));
    }

    get canCancelStatus() {
        return this.compute('canCancelStatus', () => hasAnyLink(this._links, 'cancel'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    get statusUpdates() {
        return this.compute('statusUpdates', () => {
            const updates: { status: string; color: string }[] = [];
            for (const [key, link] of Object.entries(this._links)) {
                if (key.startsWith('status/')) {
                    updates.push({ status: key.substring(7), color: link.metadata! });
                }
            }

            return updates;
        });
    }

    constructor(data?: IContentDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).createdBy = _data["createdBy"];
        (<any>this).lastModifiedBy = _data["lastModifiedBy"];
        (<any>this).data = _data["data"];
        if (_data["referenceData"]) {
            (<any>this).referenceData = {} as any;
            for (let key in _data["referenceData"]) {
                if (_data["referenceData"].hasOwnProperty(key))
                    (<any>(<any>this).referenceData)![key] = _data["referenceData"][key];
            }
        }
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).lastModified = _data["lastModified"] ? DateTime.parseISO(_data["lastModified"].toString()) : <any>undefined;
        (<any>this).status = _data["status"];
        (<any>this).newStatus = _data["newStatus"];
        (<any>this).statusColor = _data["statusColor"];
        (<any>this).newStatusColor = _data["newStatusColor"];
        (<any>this).editToken = _data["editToken"];
        (<any>this).scheduleJob = _data["scheduleJob"] ? ScheduleJobDto.fromJSON(_data["scheduleJob"]) : <any>undefined;
        (<any>this).schemaId = _data["schemaId"];
        (<any>this).schemaName = _data["schemaName"];
        (<any>this).schemaDisplayName = _data["schemaDisplayName"];
        if (Array.isArray(_data["referenceFields"])) {
            (<any>this).referenceFields = [] as any;
            for (let item of _data["referenceFields"])
                (<any>this).referenceFields!.push(FieldDto.fromJSON(item));
        }
        (<any>this).isDeleted = _data["isDeleted"];
        (<any>this).version = _data["version"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ContentDto {
        const result = new ContentDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["data"] = this.data;
        if (this.referenceData) {
            data["referenceData"] = {};
            for (let key in this.referenceData) {
                if (this.referenceData.hasOwnProperty(key))
                    (<any>data["referenceData"])[key] = (<any>this.referenceData)[key];
            }
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["newStatus"] = this.newStatus;
        data["statusColor"] = this.statusColor;
        data["newStatusColor"] = this.newStatusColor;
        data["editToken"] = this.editToken;
        data["scheduleJob"] = this.scheduleJob ? this.scheduleJob.toJSON() : <any>undefined;
        data["schemaId"] = this.schemaId;
        data["schemaName"] = this.schemaName;
        data["schemaDisplayName"] = this.schemaDisplayName;
        if (Array.isArray(this.referenceFields)) {
            data["referenceFields"] = [];
            for (let item of this.referenceFields)
                data["referenceFields"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["version"] = this.version;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IContentDto extends IResourceDto {
    /** The if of the content item. */
    readonly id: string;
    /** The user that has created the content item. */
    readonly createdBy: string;
    /** The user that has updated the content item. */
    readonly lastModifiedBy: string;
    /** The data of the content item. */
    readonly data: any;
    /** The reference data for the frontend UI. */
    readonly referenceData?: { [key: string]: { [key: string]: any; }; } | undefined;
    /** The date and time when the content item has been created. */
    readonly created: DateTime;
    /** The date and time when the content item has been modified last. */
    readonly lastModified: DateTime;
    /** The status of the content. */
    readonly status: string;
    /** The new status of the content. */
    readonly newStatus?: string | undefined;
    /** The color of the status. */
    readonly statusColor: string;
    /** The color of the new status. */
    readonly newStatusColor?: string | undefined;
    /** The UI token. */
    readonly editToken?: string | undefined;
    /** The scheduled status. */
    readonly scheduleJob?: ScheduleJobDto | undefined;
    /** The ID of the schema. */
    readonly schemaId: string;
    /** The name of the schema. */
    readonly schemaName: string;
    /** The display name of the schema. */
    readonly schemaDisplayName: string;
    /** The reference fields. */
    readonly referenceFields: FieldDto[];
    /** Indicates whether the content is deleted. */
    readonly isDeleted: boolean;
    /** The version of the content. */
    readonly version: number;
}

export class ScheduleJobDto implements IScheduleJobDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The ID of the schedule job. */
    readonly id!: string;
    /** The new status. */
    readonly status!: string;
    /** The target date and time when the content should be scheduled. */
    readonly dueTime!: DateTime;
    /** The color of the scheduled status. */
    readonly color!: string;
    /** The user who schedule the content. */
    readonly scheduledBy!: string;

    constructor(data?: IScheduleJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).id = _data["id"];
        (<any>this).status = _data["status"];
        (<any>this).dueTime = _data["dueTime"] ? DateTime.parseISO(_data["dueTime"].toString()) : <any>undefined;
        (<any>this).color = _data["color"];
        (<any>this).scheduledBy = _data["scheduledBy"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ScheduleJobDto {
        const result = new ScheduleJobDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["status"] = this.status;
        data["dueTime"] = this.dueTime ? this.dueTime.toISOString() : <any>undefined;
        data["color"] = this.color;
        data["scheduledBy"] = this.scheduledBy;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IScheduleJobDto {
    /** The ID of the schedule job. */
    readonly id: string;
    /** The new status. */
    readonly status: string;
    /** The target date and time when the content should be scheduled. */
    readonly dueTime: DateTime;
    /** The color of the scheduled status. */
    readonly color: string;
    /** The user who schedule the content. */
    readonly scheduledBy: string;
}

export class StatusInfoDto implements IStatusInfoDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the status. */
    readonly status!: string;
    /** The color of the status. */
    readonly color!: string;

    constructor(data?: IStatusInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).status = _data["status"];
        (<any>this).color = _data["color"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): StatusInfoDto {
        const result = new StatusInfoDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["status"] = this.status;
        data["color"] = this.color;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IStatusInfoDto {
    /** The name of the status. */
    readonly status: string;
    /** The color of the status. */
    readonly color: string;
}

export class QueryDto implements IQueryDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The optional list of ids to query. */
    readonly ids?: string[] | undefined;
    /** The optional odata query. */
    readonly oData?: string | undefined;
    /** The optional json query. */
    readonly q?: any | undefined;
    /** The parent id (for assets). */
    readonly parentId?: string | undefined;

    constructor(data?: IQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["ids"])) {
            (<any>this).ids = [] as any;
            for (let item of _data["ids"])
                (<any>this).ids!.push(item);
        }
        (<any>this).oData = _data["oData"];
        (<any>this).q = _data["q"];
        (<any>this).parentId = _data["parentId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): QueryDto {
        const result = new QueryDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["oData"] = this.oData;
        data["q"] = this.q;
        data["parentId"] = this.parentId;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IQueryDto {
    /** The optional list of ids to query. */
    readonly ids?: string[] | undefined;
    /** The optional odata query. */
    readonly oData?: string | undefined;
    /** The optional json query. */
    readonly q?: any | undefined;
    /** The parent id (for assets). */
    readonly parentId?: string | undefined;
}

export class BulkResultDto implements IBulkResultDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The error when the bulk job failed. */
    readonly error?: ServerErrorDto | undefined;
    /** The index of the bulk job where the result belongs to. The order can change. */
    readonly jobIndex!: number;
    /** The ID of the entity that has been handled successfully or not. */
    readonly id?: string | undefined;
    /** The ID of the entity that has been handled successfully or not. */
    readonly contentId?: string | undefined;

    constructor(data?: IBulkResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).error = _data["error"] ? ServerErrorDto.fromJSON(_data["error"]) : <any>undefined;
        (<any>this).jobIndex = _data["jobIndex"];
        (<any>this).id = _data["id"];
        (<any>this).contentId = _data["contentId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): BulkResultDto {
        const result = new BulkResultDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["jobIndex"] = this.jobIndex;
        data["id"] = this.id;
        data["contentId"] = this.contentId;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IBulkResultDto {
    /** The error when the bulk job failed. */
    readonly error?: ServerErrorDto | undefined;
    /** The index of the bulk job where the result belongs to. The order can change. */
    readonly jobIndex: number;
    /** The ID of the entity that has been handled successfully or not. */
    readonly id?: string | undefined;
    /** The ID of the entity that has been handled successfully or not. */
    readonly contentId?: string | undefined;
}

export class ImportContentsDto implements IImportContentsDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The data to import. */
    readonly datas!: { [key: string]: { [key: string]: any; }; }[];
    /** True to automatically publish the content. */
    readonly publish?: boolean;
    /** True to turn off scripting for faster inserts. Default: true. */
    readonly doNotScript?: boolean;
    /** True to turn off costly validation: Unique checks, asset checks and reference checks. Default: true. */
    readonly optimizeValidation?: boolean;

    constructor(data?: IImportContentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["datas"])) {
            (<any>this).datas = [] as any;
            for (let item of _data["datas"])
                (<any>this).datas!.push(item);
        }
        (<any>this).publish = _data["publish"];
        (<any>this).doNotScript = _data["doNotScript"];
        (<any>this).optimizeValidation = _data["optimizeValidation"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ImportContentsDto {
        const result = new ImportContentsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.datas)) {
            data["datas"] = [];
            for (let item of this.datas)
                data["datas"].push(item);
        }
        data["publish"] = this.publish;
        data["doNotScript"] = this.doNotScript;
        data["optimizeValidation"] = this.optimizeValidation;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IImportContentsDto {
    /** The data to import. */
    readonly datas: { [key: string]: { [key: string]: any; }; }[];
    /** True to automatically publish the content. */
    readonly publish?: boolean;
    /** True to turn off scripting for faster inserts. Default: true. */
    readonly doNotScript?: boolean;
    /** True to turn off costly validation: Unique checks, asset checks and reference checks. Default: true. */
    readonly optimizeValidation?: boolean;
}

export class BulkUpdateContentsDto implements IBulkUpdateContentsDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The contents to update or insert. */
    readonly jobs!: BulkUpdateContentsJobDto[];
    /** True to automatically publish the content. */
    readonly publish?: boolean;
    /** True to turn off scripting for faster inserts. Default: true. */
    readonly doNotScript?: boolean;
    /** True, to also enrich required fields. Default: false. */
    readonly enrichRequiredFields?: boolean;
    /** True to turn off validation for faster inserts. Default: false. */
    readonly doNotValidate?: boolean;
    /** True to turn off validation of workflow rules. Default: false. */
    readonly doNotValidateWorkflow?: boolean;
    /** True to check referrers of deleted contents. */
    readonly checkReferrers?: boolean;
    /** True to turn off costly validation: Unique checks, asset checks and reference checks. Default: true. */
    readonly optimizeValidation?: boolean;

    constructor(data?: IBulkUpdateContentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["jobs"])) {
            (<any>this).jobs = [] as any;
            for (let item of _data["jobs"])
                (<any>this).jobs!.push(BulkUpdateContentsJobDto.fromJSON(item));
        }
        (<any>this).publish = _data["publish"];
        (<any>this).doNotScript = _data["doNotScript"];
        (<any>this).enrichRequiredFields = _data["enrichRequiredFields"];
        (<any>this).doNotValidate = _data["doNotValidate"];
        (<any>this).doNotValidateWorkflow = _data["doNotValidateWorkflow"];
        (<any>this).checkReferrers = _data["checkReferrers"];
        (<any>this).optimizeValidation = _data["optimizeValidation"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): BulkUpdateContentsDto {
        const result = new BulkUpdateContentsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        data["publish"] = this.publish;
        data["doNotScript"] = this.doNotScript;
        data["enrichRequiredFields"] = this.enrichRequiredFields;
        data["doNotValidate"] = this.doNotValidate;
        data["doNotValidateWorkflow"] = this.doNotValidateWorkflow;
        data["checkReferrers"] = this.checkReferrers;
        data["optimizeValidation"] = this.optimizeValidation;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IBulkUpdateContentsDto {
    /** The contents to update or insert. */
    readonly jobs: BulkUpdateContentsJobDto[];
    /** True to automatically publish the content. */
    readonly publish?: boolean;
    /** True to turn off scripting for faster inserts. Default: true. */
    readonly doNotScript?: boolean;
    /** True, to also enrich required fields. Default: false. */
    readonly enrichRequiredFields?: boolean;
    /** True to turn off validation for faster inserts. Default: false. */
    readonly doNotValidate?: boolean;
    /** True to turn off validation of workflow rules. Default: false. */
    readonly doNotValidateWorkflow?: boolean;
    /** True to check referrers of deleted contents. */
    readonly checkReferrers?: boolean;
    /** True to turn off costly validation: Unique checks, asset checks and reference checks. Default: true. */
    readonly optimizeValidation?: boolean;
}

export class BulkUpdateContentsJobDto implements IBulkUpdateContentsJobDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** An optional query to identify the content to update. */
    readonly query?: QueryJsonDto | undefined;
    /** An optional ID of the content to update. */
    readonly id?: string | undefined;
    /** The data of the content when type is set to 'Upsert', 'Create', 'Update' or 'Patch. */
    readonly data?: { [key: string]: { [key: string]: any; }; } | undefined;
    /** The new status when the type is set to 'ChangeStatus' or 'Upsert'. */
    readonly status?: string | undefined;
    /** The due time. */
    readonly dueTime?: DateTime | undefined;
    /** The update type. */
    readonly type?: BulkUpdateContentType;
    /** The optional schema id or name. */
    readonly schema?: string | undefined;
    /** Makes the update as patch. */
    readonly patch?: boolean;
    /** True to delete the content permanently. */
    readonly permanent?: boolean;
    /** Enrich the data with the default values when updating a content item. */
    readonly enrichDefaults?: boolean;
    /** The number of expected items. Set it to a higher number to update multiple items when a query is defined. */
    readonly expectedCount?: number;
    /** The expected version. */
    readonly expectedVersion?: number;

    constructor(data?: IBulkUpdateContentsJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).query = _data["query"] ? QueryJsonDto.fromJSON(_data["query"]) : <any>undefined;
        (<any>this).id = _data["id"];
        if (_data["data"]) {
            (<any>this).data = {} as any;
            for (let key in _data["data"]) {
                if (_data["data"].hasOwnProperty(key))
                    (<any>(<any>this).data)![key] = _data["data"][key];
            }
        }
        (<any>this).status = _data["status"];
        (<any>this).dueTime = _data["dueTime"] ? DateTime.parseISO(_data["dueTime"].toString()) : <any>undefined;
        (<any>this).type = _data["type"];
        (<any>this).schema = _data["schema"];
        (<any>this).patch = _data["patch"];
        (<any>this).permanent = _data["permanent"];
        (<any>this).enrichDefaults = _data["enrichDefaults"];
        (<any>this).expectedCount = _data["expectedCount"];
        (<any>this).expectedVersion = _data["expectedVersion"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): BulkUpdateContentsJobDto {
        const result = new BulkUpdateContentsJobDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["query"] = this.query ? this.query.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["status"] = this.status;
        data["dueTime"] = this.dueTime ? this.dueTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["schema"] = this.schema;
        data["patch"] = this.patch;
        data["permanent"] = this.permanent;
        data["enrichDefaults"] = this.enrichDefaults;
        data["expectedCount"] = this.expectedCount;
        data["expectedVersion"] = this.expectedVersion;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IBulkUpdateContentsJobDto {
    /** An optional query to identify the content to update. */
    readonly query?: QueryJsonDto | undefined;
    /** An optional ID of the content to update. */
    readonly id?: string | undefined;
    /** The data of the content when type is set to 'Upsert', 'Create', 'Update' or 'Patch. */
    readonly data?: { [key: string]: { [key: string]: any; }; } | undefined;
    /** The new status when the type is set to 'ChangeStatus' or 'Upsert'. */
    readonly status?: string | undefined;
    /** The due time. */
    readonly dueTime?: DateTime | undefined;
    /** The update type. */
    readonly type?: BulkUpdateContentType;
    /** The optional schema id or name. */
    readonly schema?: string | undefined;
    /** Makes the update as patch. */
    readonly patch?: boolean;
    /** True to delete the content permanently. */
    readonly permanent?: boolean;
    /** Enrich the data with the default values when updating a content item. */
    readonly enrichDefaults?: boolean;
    /** The number of expected items. Set it to a higher number to update multiple items when a query is defined. */
    readonly expectedCount?: number;
    /** The expected version. */
    readonly expectedVersion?: number;
}

export class QueryJsonDto implements IQueryJsonDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    readonly filter?: any | undefined;
    readonly fullText?: string | undefined;
    readonly collation?: string | undefined;
    readonly skip!: number;
    readonly take!: number;
    readonly random!: number;
    readonly top!: number;
    readonly sort?: SortNodeDto[] | undefined;

    constructor(data?: IQueryJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).filter = _data["filter"];
        (<any>this).fullText = _data["fullText"];
        (<any>this).collation = _data["collation"];
        (<any>this).skip = _data["skip"];
        (<any>this).take = _data["take"];
        (<any>this).random = _data["random"];
        (<any>this).top = _data["top"];
        if (Array.isArray(_data["sort"])) {
            (<any>this).sort = [] as any;
            for (let item of _data["sort"])
                (<any>this).sort!.push(SortNodeDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): QueryJsonDto {
        const result = new QueryJsonDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["filter"] = this.filter;
        data["fullText"] = this.fullText;
        data["collation"] = this.collation;
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["random"] = this.random;
        data["top"] = this.top;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IQueryJsonDto {
    readonly filter?: any | undefined;
    readonly fullText?: string | undefined;
    readonly collation?: string | undefined;
    readonly skip: number;
    readonly take: number;
    readonly random: number;
    readonly top: number;
    readonly sort?: SortNodeDto[] | undefined;
}

export class SortNodeDto implements ISortNodeDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    readonly path!: string;
    readonly order!: SortOrder;

    constructor(data?: ISortNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).path = _data["path"];
        (<any>this).order = _data["order"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): SortNodeDto {
        const result = new SortNodeDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["path"] = this.path;
        data["order"] = this.order;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ISortNodeDto {
    readonly path: string;
    readonly order: SortOrder;
}

export type BulkUpdateContentType = "Upsert" | "ChangeStatus" | "Create" | "Delete" | "Patch" | "Update" | "Validate" | "EnrichDefaults";

export const BulkUpdateContentTypeValues: ReadonlyArray<BulkUpdateContentType> = [
	"Upsert",
	"ChangeStatus",
	"Create",
	"Delete",
	"Patch",
	"Update",
	"Validate",
	"EnrichDefaults"
];

export class ChangeStatusDto implements IChangeStatusDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The new status. */
    readonly status!: string;
    /** The due time. */
    readonly dueTime?: DateTime | undefined;
    /** True to check referrers of this content. */
    readonly checkReferrers?: boolean;

    constructor(data?: IChangeStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).status = _data["status"];
        (<any>this).dueTime = _data["dueTime"] ? DateTime.parseISO(_data["dueTime"].toString()) : <any>undefined;
        (<any>this).checkReferrers = _data["checkReferrers"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ChangeStatusDto {
        const result = new ChangeStatusDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["status"] = this.status;
        data["dueTime"] = this.dueTime ? this.dueTime.toISOString() : <any>undefined;
        data["checkReferrers"] = this.checkReferrers;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IChangeStatusDto {
    /** The new status. */
    readonly status: string;
    /** The due time. */
    readonly dueTime?: DateTime | undefined;
    /** True to check referrers of this content. */
    readonly checkReferrers?: boolean;
}

export class AllContentsByPostDto implements IAllContentsByPostDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The list of ids to query. */
    readonly ids?: string[] | undefined;
    /** The start of the schedule. */
    readonly scheduledFrom?: DateTime | undefined;
    /** The end of the schedule. */
    readonly scheduledTo?: DateTime | undefined;
    /** The ID of the referencing content item. */
    readonly referencing?: string | undefined;
    /** The ID of the reference content item. */
    readonly references?: string | undefined;
    /** The optional odata query. */
    readonly oData?: string | undefined;
    /** The optional json query. */
    readonly q?: any | undefined;

    constructor(data?: IAllContentsByPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["ids"])) {
            (<any>this).ids = [] as any;
            for (let item of _data["ids"])
                (<any>this).ids!.push(item);
        }
        (<any>this).scheduledFrom = _data["scheduledFrom"] ? DateTime.parseISO(_data["scheduledFrom"].toString()) : <any>undefined;
        (<any>this).scheduledTo = _data["scheduledTo"] ? DateTime.parseISO(_data["scheduledTo"].toString()) : <any>undefined;
        (<any>this).referencing = _data["referencing"];
        (<any>this).references = _data["references"];
        (<any>this).oData = _data["oData"];
        (<any>this).q = _data["q"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AllContentsByPostDto {
        const result = new AllContentsByPostDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["scheduledFrom"] = this.scheduledFrom ? this.scheduledFrom.toISOString() : <any>undefined;
        data["scheduledTo"] = this.scheduledTo ? this.scheduledTo.toISOString() : <any>undefined;
        data["referencing"] = this.referencing;
        data["references"] = this.references;
        data["oData"] = this.oData;
        data["q"] = this.q;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAllContentsByPostDto {
    /** The list of ids to query. */
    readonly ids?: string[] | undefined;
    /** The start of the schedule. */
    readonly scheduledFrom?: DateTime | undefined;
    /** The end of the schedule. */
    readonly scheduledTo?: DateTime | undefined;
    /** The ID of the referencing content item. */
    readonly referencing?: string | undefined;
    /** The ID of the reference content item. */
    readonly references?: string | undefined;
    /** The optional odata query. */
    readonly oData?: string | undefined;
    /** The optional json query. */
    readonly q?: any | undefined;
}

export class BackupJobsDto extends ResourceDto implements IBackupJobsDto {
    /** The backups. */
    readonly items!: BackupJobDto[];

    constructor(data?: IBackupJobsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(BackupJobDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): BackupJobsDto {
        const result = new BackupJobsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IBackupJobsDto extends IResourceDto {
    /** The backups. */
    readonly items: BackupJobDto[];
}

export class BackupJobDto extends ResourceDto implements IBackupJobDto {
    /** The ID of the backup job. */
    readonly id!: string;
    /** The time when the job has been started. */
    readonly started!: DateTime;
    /** The time when the job has been stopped. */
    readonly stopped?: DateTime | undefined;
    /** The number of handled events. */
    readonly handledEvents!: number;
    /** The number of handled assets. */
    readonly handledAssets!: number;
    /** The status of the operation. */
    readonly status!: JobStatus;

    constructor(data?: IBackupJobDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).started = _data["started"] ? DateTime.parseISO(_data["started"].toString()) : <any>undefined;
        (<any>this).stopped = _data["stopped"] ? DateTime.parseISO(_data["stopped"].toString()) : <any>undefined;
        (<any>this).handledEvents = _data["handledEvents"];
        (<any>this).handledAssets = _data["handledAssets"];
        (<any>this).status = _data["status"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): BackupJobDto {
        const result = new BackupJobDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["stopped"] = this.stopped ? this.stopped.toISOString() : <any>undefined;
        data["handledEvents"] = this.handledEvents;
        data["handledAssets"] = this.handledAssets;
        data["status"] = this.status;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IBackupJobDto extends IResourceDto {
    /** The ID of the backup job. */
    readonly id: string;
    /** The time when the job has been started. */
    readonly started: DateTime;
    /** The time when the job has been stopped. */
    readonly stopped?: DateTime | undefined;
    /** The number of handled events. */
    readonly handledEvents: number;
    /** The number of handled assets. */
    readonly handledAssets: number;
    /** The status of the operation. */
    readonly status: JobStatus;
}

export class RestoreJobDto implements IRestoreJobDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The uri to load from. */
    readonly url!: string;
    /** The status log. */
    readonly log!: string[];
    /** The time when the job has been started. */
    readonly started!: DateTime;
    /** The time when the job has been stopped. */
    readonly stopped?: DateTime | undefined;
    /** The status of the operation. */
    readonly status!: JobStatus;

    constructor(data?: IRestoreJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).url = _data["url"];
        if (Array.isArray(_data["log"])) {
            (<any>this).log = [] as any;
            for (let item of _data["log"])
                (<any>this).log!.push(item);
        }
        (<any>this).started = _data["started"] ? DateTime.parseISO(_data["started"].toString()) : <any>undefined;
        (<any>this).stopped = _data["stopped"] ? DateTime.parseISO(_data["stopped"].toString()) : <any>undefined;
        (<any>this).status = _data["status"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RestoreJobDto {
        const result = new RestoreJobDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["url"] = this.url;
        if (Array.isArray(this.log)) {
            data["log"] = [];
            for (let item of this.log)
                data["log"].push(item);
        }
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["stopped"] = this.stopped ? this.stopped.toISOString() : <any>undefined;
        data["status"] = this.status;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IRestoreJobDto {
    /** The uri to load from. */
    readonly url: string;
    /** The status log. */
    readonly log: string[];
    /** The time when the job has been started. */
    readonly started: DateTime;
    /** The time when the job has been stopped. */
    readonly stopped?: DateTime | undefined;
    /** The status of the operation. */
    readonly status: JobStatus;
}

export class RestoreRequestDto implements IRestoreRequestDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the app. */
    readonly name?: string | undefined;
    /** The url to the restore file. */
    readonly url!: string;

    constructor(data?: IRestoreRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).url = _data["url"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RestoreRequestDto {
        const result = new RestoreRequestDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["url"] = this.url;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IRestoreRequestDto {
    /** The name of the app. */
    readonly name?: string | undefined;
    /** The url to the restore file. */
    readonly url: string;
}

export type ResizeMode = "Crop" | "CropUpsize" | "Pad" | "BoxPad" | "Max" | "Min" | "Stretch";

export const ResizeModeValues: ReadonlyArray<ResizeMode> = [
	"Crop",
	"CropUpsize",
	"Pad",
	"BoxPad",
	"Max",
	"Min",
	"Stretch"
];

export type ImageFormat = "AVIF" | "BMP" | "GIF" | "JPEG" | "PNG" | "TGA" | "TIFF" | "WEBP";

export const ImageFormatValues: ReadonlyArray<ImageFormat> = [
	"AVIF",
	"BMP",
	"GIF",
	"JPEG",
	"PNG",
	"TGA",
	"TIFF",
	"WEBP"
];

export type WatermarkAnchor = "TopLeft" | "TopRight" | "BottomLeft" | "BottomRight" | "Center";

export const WatermarkAnchorValues: ReadonlyArray<WatermarkAnchor> = [
	"TopLeft",
	"TopRight",
	"BottomLeft",
	"BottomRight",
	"Center"
];

export class AssetFoldersDto extends ResourceDto implements IAssetFoldersDto {
    /** The total number of assets. */
    readonly total!: number;
    /** The assets folders. */
    readonly items!: AssetFolderDto[];
    /** The path to the current folder. */
    readonly path!: AssetFolderDto[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    constructor(data?: IAssetFoldersDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).total = _data["total"];
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(AssetFolderDto.fromJSON(item));
        }
        if (Array.isArray(_data["path"])) {
            (<any>this).path = [] as any;
            for (let item of _data["path"])
                (<any>this).path!.push(AssetFolderDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AssetFoldersDto {
        const result = new AssetFoldersDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.path)) {
            data["path"] = [];
            for (let item of this.path)
                data["path"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAssetFoldersDto extends IResourceDto {
    /** The total number of assets. */
    readonly total: number;
    /** The assets folders. */
    readonly items: AssetFolderDto[];
    /** The path to the current folder. */
    readonly path: AssetFolderDto[];
}

export class AssetFolderDto extends ResourceDto implements IAssetFolderDto {
    /** The ID of the asset. */
    readonly id!: string;
    /** The ID of the parent folder. Empty for files without parent. */
    readonly parentId!: string;
    /** The folder name. */
    readonly folderName!: string;
    /** The version of the asset folder. */
    readonly version!: number;

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'update'));
    }

    get canMove() {
        return this.compute('canMove', () => hasAnyLink(this._links, 'move'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IAssetFolderDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).parentId = _data["parentId"];
        (<any>this).folderName = _data["folderName"];
        (<any>this).version = _data["version"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AssetFolderDto {
        const result = new AssetFolderDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["folderName"] = this.folderName;
        data["version"] = this.version;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAssetFolderDto extends IResourceDto {
    /** The ID of the asset. */
    readonly id: string;
    /** The ID of the parent folder. Empty for files without parent. */
    readonly parentId: string;
    /** The folder name. */
    readonly folderName: string;
    /** The version of the asset folder. */
    readonly version: number;
}

export type AssetFolderScope = "PathAndItems" | "Path" | "Items";

export const AssetFolderScopeValues: ReadonlyArray<AssetFolderScope> = [
	"PathAndItems",
	"Path",
	"Items"
];

export class CreateAssetFolderDto implements ICreateAssetFolderDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the folder. */
    readonly folderName!: string;
    /** The ID of the parent folder. */
    readonly parentId?: string | undefined;

    constructor(data?: ICreateAssetFolderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).folderName = _data["folderName"];
        (<any>this).parentId = _data["parentId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateAssetFolderDto {
        const result = new CreateAssetFolderDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["folderName"] = this.folderName;
        data["parentId"] = this.parentId;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICreateAssetFolderDto {
    /** The name of the folder. */
    readonly folderName: string;
    /** The ID of the parent folder. */
    readonly parentId?: string | undefined;
}

export class RenameAssetFolderDto implements IRenameAssetFolderDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the folder. */
    readonly folderName!: string;

    constructor(data?: IRenameAssetFolderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).folderName = _data["folderName"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RenameAssetFolderDto {
        const result = new RenameAssetFolderDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["folderName"] = this.folderName;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IRenameAssetFolderDto {
    /** The name of the folder. */
    readonly folderName: string;
}

export class MoveAssetFolderDto implements IMoveAssetFolderDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The parent folder id. */
    readonly parentId?: string | undefined;

    constructor(data?: IMoveAssetFolderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).parentId = _data["parentId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): MoveAssetFolderDto {
        const result = new MoveAssetFolderDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["parentId"] = this.parentId;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IMoveAssetFolderDto {
    /** The parent folder id. */
    readonly parentId?: string | undefined;
}

export class RenameTagDto implements IRenameTagDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The new name for the tag. */
    readonly tagName!: string;

    constructor(data?: IRenameTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).tagName = _data["tagName"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RenameTagDto {
        const result = new RenameTagDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["tagName"] = this.tagName;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IRenameTagDto {
    /** The new name for the tag. */
    readonly tagName: string;
}

export class AssetsDto extends ResourceDto implements IAssetsDto {
    /** The total number of assets. */
    readonly total!: number;
    /** The assets. */
    readonly items!: AssetDto[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    get canRenameTag() {
        return this.compute('canRenameTag', () => hasAnyLink(this._links, 'tags/rename'));
    }

    constructor(data?: IAssetsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).total = _data["total"];
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(AssetDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AssetsDto {
        const result = new AssetsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAssetsDto extends IResourceDto {
    /** The total number of assets. */
    readonly total: number;
    /** The assets. */
    readonly items: AssetDto[];
}

export class AssetDto extends ResourceDto implements IAssetDto {
    /** The ID of the asset. */
    readonly id!: string;
    /** The ID of the parent folder. Empty for files without parent. */
    readonly parentId!: string;
    /** The file name. */
    readonly fileName!: string;
    /** The file hash. */
    readonly fileHash?: string | undefined;
    /** True, when the asset is not public. */
    readonly isProtected!: boolean;
    /** The slug. */
    readonly slug!: string;
    /** The mime type. */
    readonly mimeType!: string;
    /** The file type. */
    readonly fileType!: string;
    /** The formatted text representation of the metadata. */
    readonly metadataText!: string;
    /** The UI token. */
    readonly editToken?: string | undefined;
    /** The asset metadata. */
    readonly metadata!: { [key: string]: any; };
    /** The asset tags. */
    readonly tags!: string[];
    /** The size of the file in bytes. */
    readonly fileSize!: number;
    /** The version of the file. */
    readonly fileVersion!: number;
    /** The type of the asset. */
    readonly type!: AssetType;
    /** The user that has created the schema. */
    readonly createdBy!: string;
    /** The user that has updated the asset. */
    readonly lastModifiedBy!: string;
    /** The date and time when the asset has been created. */
    readonly created!: DateTime;
    /** The date and time when the asset has been modified last. */
    readonly lastModified!: DateTime;
    /** The version of the asset. */
    readonly version!: number;
    /** The metadata. */
    readonly _meta?: AssetMetaDto | undefined;
    /** Determines of the created file is an image. */
    readonly isImage!: boolean;
    /** The width of the image in pixels if the asset is an image. */
    readonly pixelWidth?: number | undefined;
    /** The height of the image in pixels if the asset is an image. */
    readonly pixelHeight?: number | undefined;

    public get isDuplicate() {
        return this.compute('isDuplicate', () => this._meta && this._meta['isDuplicate'] === 'true');
    }

    public get contentUrl() {
        return this.compute('contentUrl', () => this._links['content']?.href);
    }

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'update'));
    }

    get canMove() {
        return this.compute('canMove', () => hasAnyLink(this._links, 'move'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    get canUpload() {
        return this.compute('canUpload', () => hasAnyLink(this._links, 'upload'));
    }

    get canPreview() {
        return this.compute('canPreview', () => {
            const SVG_PREVIEW_LIMIT = 10 * 1024;
            const MIME_TIFF = 'image/tiff';
            const MIME_SVG = 'image/svg+xml';

            const canPreview =
                (this.mimeType !== MIME_TIFF && this.type === 'Image') ||
                (this.mimeType === MIME_SVG && this.fileSize < SVG_PREVIEW_LIMIT);

            return canPreview;
        });
    }

    public get fileNameWithoutExtension() {
        return this.compute('fileNameWithoutExtension', () => {
            const index = this.fileName.lastIndexOf('.');

            if (index > 0) {
                return this.fileName.substring(0, index);
            } else {
                return this.fileName;
            }

        });
    }

    public fullUrl(apiUrl: ApiUrlConfig) {
        return apiUrl.buildUrl(this.contentUrl);
    }

    constructor(data?: IAssetDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).parentId = _data["parentId"];
        (<any>this).fileName = _data["fileName"];
        (<any>this).fileHash = _data["fileHash"];
        (<any>this).isProtected = _data["isProtected"];
        (<any>this).slug = _data["slug"];
        (<any>this).mimeType = _data["mimeType"];
        (<any>this).fileType = _data["fileType"];
        (<any>this).metadataText = _data["metadataText"];
        (<any>this).editToken = _data["editToken"];
        if (_data["metadata"]) {
            (<any>this).metadata = {} as any;
            for (let key in _data["metadata"]) {
                if (_data["metadata"].hasOwnProperty(key))
                    (<any>(<any>this).metadata)![key] = _data["metadata"][key];
            }
        }
        if (Array.isArray(_data["tags"])) {
            (<any>this).tags = [] as any;
            for (let item of _data["tags"])
                (<any>this).tags!.push(item);
        }
        (<any>this).fileSize = _data["fileSize"];
        (<any>this).fileVersion = _data["fileVersion"];
        (<any>this).type = _data["type"];
        (<any>this).createdBy = _data["createdBy"];
        (<any>this).lastModifiedBy = _data["lastModifiedBy"];
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).lastModified = _data["lastModified"] ? DateTime.parseISO(_data["lastModified"].toString()) : <any>undefined;
        (<any>this).version = _data["version"];
        (<any>this)._meta = _data["_meta"] ? AssetMetaDto.fromJSON(_data["_meta"]) : <any>undefined;
        (<any>this).isImage = _data["isImage"];
        (<any>this).pixelWidth = _data["pixelWidth"];
        (<any>this).pixelHeight = _data["pixelHeight"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AssetDto {
        const result = new AssetDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["fileName"] = this.fileName;
        data["fileHash"] = this.fileHash;
        data["isProtected"] = this.isProtected;
        data["slug"] = this.slug;
        data["mimeType"] = this.mimeType;
        data["fileType"] = this.fileType;
        data["metadataText"] = this.metadataText;
        data["editToken"] = this.editToken;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["fileSize"] = this.fileSize;
        data["fileVersion"] = this.fileVersion;
        data["type"] = this.type;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["_meta"] = this._meta ? this._meta.toJSON() : <any>undefined;
        data["isImage"] = this.isImage;
        data["pixelWidth"] = this.pixelWidth;
        data["pixelHeight"] = this.pixelHeight;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAssetDto extends IResourceDto {
    /** The ID of the asset. */
    readonly id: string;
    /** The ID of the parent folder. Empty for files without parent. */
    readonly parentId: string;
    /** The file name. */
    readonly fileName: string;
    /** The file hash. */
    readonly fileHash?: string | undefined;
    /** True, when the asset is not public. */
    readonly isProtected: boolean;
    /** The slug. */
    readonly slug: string;
    /** The mime type. */
    readonly mimeType: string;
    /** The file type. */
    readonly fileType: string;
    /** The formatted text representation of the metadata. */
    readonly metadataText: string;
    /** The UI token. */
    readonly editToken?: string | undefined;
    /** The asset metadata. */
    readonly metadata: { [key: string]: any; };
    /** The asset tags. */
    readonly tags: string[];
    /** The size of the file in bytes. */
    readonly fileSize: number;
    /** The version of the file. */
    readonly fileVersion: number;
    /** The type of the asset. */
    readonly type: AssetType;
    /** The user that has created the schema. */
    readonly createdBy: string;
    /** The user that has updated the asset. */
    readonly lastModifiedBy: string;
    /** The date and time when the asset has been created. */
    readonly created: DateTime;
    /** The date and time when the asset has been modified last. */
    readonly lastModified: DateTime;
    /** The version of the asset. */
    readonly version: number;
    /** The metadata. */
    readonly _meta?: AssetMetaDto | undefined;
    /** Determines of the created file is an image. */
    readonly isImage: boolean;
    /** The width of the image in pixels if the asset is an image. */
    readonly pixelWidth?: number | undefined;
    /** The height of the image in pixels if the asset is an image. */
    readonly pixelHeight?: number | undefined;
}

export class AssetMetaDto implements IAssetMetaDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Indicates whether the asset is a duplicate. */
    readonly isDuplicate!: string;

    constructor(data?: IAssetMetaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).isDuplicate = _data["isDuplicate"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AssetMetaDto {
        const result = new AssetMetaDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["isDuplicate"] = this.isDuplicate;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAssetMetaDto {
    /** Indicates whether the asset is a duplicate. */
    readonly isDuplicate: string;
}

export class BulkUpdateAssetsDto implements IBulkUpdateAssetsDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The contents to update or insert. */
    readonly jobs?: BulkUpdateAssetsJobDto[] | undefined;
    /** True to check referrers of deleted assets. */
    readonly checkReferrers?: boolean;
    /** True to turn off costly validation: Folder checks. Default: true. */
    readonly optimizeValidation?: boolean;
    /** True to turn off scripting for faster inserts. Default: true. */
    readonly doNotScript?: boolean;

    constructor(data?: IBulkUpdateAssetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["jobs"])) {
            (<any>this).jobs = [] as any;
            for (let item of _data["jobs"])
                (<any>this).jobs!.push(BulkUpdateAssetsJobDto.fromJSON(item));
        }
        (<any>this).checkReferrers = _data["checkReferrers"];
        (<any>this).optimizeValidation = _data["optimizeValidation"];
        (<any>this).doNotScript = _data["doNotScript"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): BulkUpdateAssetsDto {
        const result = new BulkUpdateAssetsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        data["checkReferrers"] = this.checkReferrers;
        data["optimizeValidation"] = this.optimizeValidation;
        data["doNotScript"] = this.doNotScript;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IBulkUpdateAssetsDto {
    /** The contents to update or insert. */
    readonly jobs?: BulkUpdateAssetsJobDto[] | undefined;
    /** True to check referrers of deleted assets. */
    readonly checkReferrers?: boolean;
    /** True to turn off costly validation: Folder checks. Default: true. */
    readonly optimizeValidation?: boolean;
    /** True to turn off scripting for faster inserts. Default: true. */
    readonly doNotScript?: boolean;
}

export class BulkUpdateAssetsJobDto implements IBulkUpdateAssetsJobDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** An optional ID of the asset to update. */
    readonly id?: string | undefined;
    /** The update type. */
    readonly type?: BulkUpdateAssetType;
    /** The parent folder id. */
    readonly parentId?: string | undefined;
    /** The new name of the asset. */
    readonly fileName?: string | undefined;
    /** The new slug of the asset. */
    readonly slug?: string | undefined;
    /** True, when the asset is not public. */
    readonly isProtected?: boolean | undefined;
    /** The new asset tags. */
    readonly tags?: string[] | undefined;
    /** The asset metadata. */
    readonly metadata?: { [key: string]: any; } | undefined;
    /** True to delete the asset permanently. */
    readonly permanent?: boolean;
    /** The expected version. */
    readonly expectedVersion?: number;

    constructor(data?: IBulkUpdateAssetsJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).id = _data["id"];
        (<any>this).type = _data["type"];
        (<any>this).parentId = _data["parentId"];
        (<any>this).fileName = _data["fileName"];
        (<any>this).slug = _data["slug"];
        (<any>this).isProtected = _data["isProtected"];
        if (Array.isArray(_data["tags"])) {
            (<any>this).tags = [] as any;
            for (let item of _data["tags"])
                (<any>this).tags!.push(item);
        }
        if (_data["metadata"]) {
            (<any>this).metadata = {} as any;
            for (let key in _data["metadata"]) {
                if (_data["metadata"].hasOwnProperty(key))
                    (<any>(<any>this).metadata)![key] = _data["metadata"][key];
            }
        }
        (<any>this).permanent = _data["permanent"];
        (<any>this).expectedVersion = _data["expectedVersion"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): BulkUpdateAssetsJobDto {
        const result = new BulkUpdateAssetsJobDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["type"] = this.type;
        data["parentId"] = this.parentId;
        data["fileName"] = this.fileName;
        data["slug"] = this.slug;
        data["isProtected"] = this.isProtected;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["permanent"] = this.permanent;
        data["expectedVersion"] = this.expectedVersion;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IBulkUpdateAssetsJobDto {
    /** An optional ID of the asset to update. */
    readonly id?: string | undefined;
    /** The update type. */
    readonly type?: BulkUpdateAssetType;
    /** The parent folder id. */
    readonly parentId?: string | undefined;
    /** The new name of the asset. */
    readonly fileName?: string | undefined;
    /** The new slug of the asset. */
    readonly slug?: string | undefined;
    /** True, when the asset is not public. */
    readonly isProtected?: boolean | undefined;
    /** The new asset tags. */
    readonly tags?: string[] | undefined;
    /** The asset metadata. */
    readonly metadata?: { [key: string]: any; } | undefined;
    /** True to delete the asset permanently. */
    readonly permanent?: boolean;
    /** The expected version. */
    readonly expectedVersion?: number;
}

export type BulkUpdateAssetType = "Annotate" | "Move" | "Delete";

export const BulkUpdateAssetTypeValues: ReadonlyArray<BulkUpdateAssetType> = [
	"Annotate",
	"Move",
	"Delete"
];

export class AnnotateAssetDto implements IAnnotateAssetDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The new name of the asset. */
    readonly fileName?: string | undefined;
    /** The new slug of the asset. */
    readonly slug?: string | undefined;
    /** True, when the asset is not public. */
    readonly isProtected?: boolean | undefined;
    /** The new asset tags. */
    readonly tags?: string[] | undefined;
    /** The asset metadata. */
    readonly metadata?: { [key: string]: any; } | undefined;

    constructor(data?: IAnnotateAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).fileName = _data["fileName"];
        (<any>this).slug = _data["slug"];
        (<any>this).isProtected = _data["isProtected"];
        if (Array.isArray(_data["tags"])) {
            (<any>this).tags = [] as any;
            for (let item of _data["tags"])
                (<any>this).tags!.push(item);
        }
        if (_data["metadata"]) {
            (<any>this).metadata = {} as any;
            for (let key in _data["metadata"]) {
                if (_data["metadata"].hasOwnProperty(key))
                    (<any>(<any>this).metadata)![key] = _data["metadata"][key];
            }
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AnnotateAssetDto {
        const result = new AnnotateAssetDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["fileName"] = this.fileName;
        data["slug"] = this.slug;
        data["isProtected"] = this.isProtected;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAnnotateAssetDto {
    /** The new name of the asset. */
    readonly fileName?: string | undefined;
    /** The new slug of the asset. */
    readonly slug?: string | undefined;
    /** True, when the asset is not public. */
    readonly isProtected?: boolean | undefined;
    /** The new asset tags. */
    readonly tags?: string[] | undefined;
    /** The asset metadata. */
    readonly metadata?: { [key: string]: any; } | undefined;
}

export class MoveAssetDto implements IMoveAssetDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The parent folder id. */
    readonly parentId?: string | undefined;

    constructor(data?: IMoveAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).parentId = _data["parentId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): MoveAssetDto {
        const result = new MoveAssetDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["parentId"] = this.parentId;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IMoveAssetDto {
    /** The parent folder id. */
    readonly parentId?: string | undefined;
}

export class AssetScriptsDto extends ResourceDto implements IAssetScriptsDto {
    /** The script that is executed for each asset when querying assets. */
    readonly query?: string | undefined;
    /** The script that is executed for all assets when querying assets. */
    readonly queryPre?: string | undefined;
    /** The script that is executed when creating an asset. */
    readonly create?: string | undefined;
    /** The script that is executed when updating a content. */
    readonly update?: string | undefined;
    /** The script that is executed when annotating a content. */
    readonly annotate?: string | undefined;
    /** The script that is executed when moving a content. */
    readonly move?: string | undefined;
    /** The script that is executed when deleting a content. */
    readonly delete?: string | undefined;
    /** The version of the app. */
    readonly version!: number;

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IAssetScriptsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).query = _data["query"];
        (<any>this).queryPre = _data["queryPre"];
        (<any>this).create = _data["create"];
        (<any>this).update = _data["update"];
        (<any>this).annotate = _data["annotate"];
        (<any>this).move = _data["move"];
        (<any>this).delete = _data["delete"];
        (<any>this).version = _data["version"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AssetScriptsDto {
        const result = new AssetScriptsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["query"] = this.query;
        data["queryPre"] = this.queryPre;
        data["create"] = this.create;
        data["update"] = this.update;
        data["annotate"] = this.annotate;
        data["move"] = this.move;
        data["delete"] = this.delete;
        data["version"] = this.version;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAssetScriptsDto extends IResourceDto {
    /** The script that is executed for each asset when querying assets. */
    readonly query?: string | undefined;
    /** The script that is executed for all assets when querying assets. */
    readonly queryPre?: string | undefined;
    /** The script that is executed when creating an asset. */
    readonly create?: string | undefined;
    /** The script that is executed when updating a content. */
    readonly update?: string | undefined;
    /** The script that is executed when annotating a content. */
    readonly annotate?: string | undefined;
    /** The script that is executed when moving a content. */
    readonly move?: string | undefined;
    /** The script that is executed when deleting a content. */
    readonly delete?: string | undefined;
    /** The version of the app. */
    readonly version: number;
}

export class UpdateAssetScriptsDto implements IUpdateAssetScriptsDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The script that is executed for each asset when querying assets. */
    readonly query?: string | undefined;
    /** The script that is executed for all assets when querying assets. */
    readonly queryPre?: string | undefined;
    /** The script that is executed when creating an asset. */
    readonly create?: string | undefined;
    /** The script that is executed when updating a content. */
    readonly update?: string | undefined;
    /** The script that is executed when annotating a content. */
    readonly annotate?: string | undefined;
    /** The script that is executed when moving a content. */
    readonly move?: string | undefined;
    /** The script that is executed when deleting a content. */
    readonly delete?: string | undefined;

    constructor(data?: IUpdateAssetScriptsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).query = _data["query"];
        (<any>this).queryPre = _data["queryPre"];
        (<any>this).create = _data["create"];
        (<any>this).update = _data["update"];
        (<any>this).annotate = _data["annotate"];
        (<any>this).move = _data["move"];
        (<any>this).delete = _data["delete"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateAssetScriptsDto {
        const result = new UpdateAssetScriptsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["query"] = this.query;
        data["queryPre"] = this.queryPre;
        data["create"] = this.create;
        data["update"] = this.update;
        data["annotate"] = this.annotate;
        data["move"] = this.move;
        data["delete"] = this.delete;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateAssetScriptsDto {
    /** The script that is executed for each asset when querying assets. */
    readonly query?: string | undefined;
    /** The script that is executed for all assets when querying assets. */
    readonly queryPre?: string | undefined;
    /** The script that is executed when creating an asset. */
    readonly create?: string | undefined;
    /** The script that is executed when updating a content. */
    readonly update?: string | undefined;
    /** The script that is executed when annotating a content. */
    readonly annotate?: string | undefined;
    /** The script that is executed when moving a content. */
    readonly move?: string | undefined;
    /** The script that is executed when deleting a content. */
    readonly delete?: string | undefined;
}

export class ClientsDto extends ResourceDto implements IClientsDto {
    /** The clients. */
    readonly items!: ClientDto[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    constructor(data?: IClientsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(ClientDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ClientsDto {
        const result = new ClientsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IClientsDto extends IResourceDto {
    /** The clients. */
    readonly items: ClientDto[];
}

export class ClientDto extends ResourceDto implements IClientDto {
    /** The client id. */
    readonly id!: string;
    /** The client secret. */
    readonly secret!: string;
    /** The client name. */
    readonly name!: string;
    /** The role of the client. */
    readonly role?: string | undefined;
    /** The number of allowed api calls per month for this client. */
    readonly apiCallsLimit!: number;
    /** The number of allowed api traffic bytes per month for this client. */
    readonly apiTrafficLimit!: number;
    /** True to allow anonymous access without an access token for this client. */
    readonly allowAnonymous!: boolean;

    get canRevoke() {
        return this.compute('canRevoke', () => hasAnyLink(this._links, 'delete'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IClientDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).secret = _data["secret"];
        (<any>this).name = _data["name"];
        (<any>this).role = _data["role"];
        (<any>this).apiCallsLimit = _data["apiCallsLimit"];
        (<any>this).apiTrafficLimit = _data["apiTrafficLimit"];
        (<any>this).allowAnonymous = _data["allowAnonymous"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): ClientDto {
        const result = new ClientDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["secret"] = this.secret;
        data["name"] = this.name;
        data["role"] = this.role;
        data["apiCallsLimit"] = this.apiCallsLimit;
        data["apiTrafficLimit"] = this.apiTrafficLimit;
        data["allowAnonymous"] = this.allowAnonymous;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IClientDto extends IResourceDto {
    /** The client id. */
    readonly id: string;
    /** The client secret. */
    readonly secret: string;
    /** The client name. */
    readonly name: string;
    /** The role of the client. */
    readonly role?: string | undefined;
    /** The number of allowed api calls per month for this client. */
    readonly apiCallsLimit: number;
    /** The number of allowed api traffic bytes per month for this client. */
    readonly apiTrafficLimit: number;
    /** True to allow anonymous access without an access token for this client. */
    readonly allowAnonymous: boolean;
}

export class CreateClientDto implements ICreateClientDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The ID of the client. */
    readonly id!: string;

    constructor(data?: ICreateClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).id = _data["id"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateClientDto {
        const result = new CreateClientDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICreateClientDto {
    /** The ID of the client. */
    readonly id: string;
}

export class UpdateClientDto implements IUpdateClientDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The new display name of the client. */
    readonly name?: string | undefined;
    /** The role of the client. */
    readonly role?: string | undefined;
    /** True to allow anonymous access without an access token for this client. */
    readonly allowAnonymous?: boolean | undefined;
    /** The number of allowed api calls per month for this client. */
    readonly apiCallsLimit?: number | undefined;
    /** The number of allowed api traffic bytes per month for this client. */
    readonly apiTrafficLimit?: number | undefined;

    constructor(data?: IUpdateClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).role = _data["role"];
        (<any>this).allowAnonymous = _data["allowAnonymous"];
        (<any>this).apiCallsLimit = _data["apiCallsLimit"];
        (<any>this).apiTrafficLimit = _data["apiTrafficLimit"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateClientDto {
        const result = new UpdateClientDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["role"] = this.role;
        data["allowAnonymous"] = this.allowAnonymous;
        data["apiCallsLimit"] = this.apiCallsLimit;
        data["apiTrafficLimit"] = this.apiTrafficLimit;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateClientDto {
    /** The new display name of the client. */
    readonly name?: string | undefined;
    /** The role of the client. */
    readonly role?: string | undefined;
    /** True to allow anonymous access without an access token for this client. */
    readonly allowAnonymous?: boolean | undefined;
    /** The number of allowed api calls per month for this client. */
    readonly apiCallsLimit?: number | undefined;
    /** The number of allowed api traffic bytes per month for this client. */
    readonly apiTrafficLimit?: number | undefined;
}

export class AppLanguagesDto extends ResourceDto implements IAppLanguagesDto {
    /** The languages. */
    readonly items!: AppLanguageDto[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    constructor(data?: IAppLanguagesDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(AppLanguageDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AppLanguagesDto {
        const result = new AppLanguagesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAppLanguagesDto extends IResourceDto {
    /** The languages. */
    readonly items: AppLanguageDto[];
}

export class AppLanguageDto extends ResourceDto implements IAppLanguageDto {
    /** The iso code of the language. */
    readonly iso2Code!: string;
    /** The english name of the language. */
    readonly englishName!: string;
    /** The fallback languages. */
    readonly fallback!: string[];
    /** Indicates if the language is the master language. */
    readonly isMaster!: boolean;
    /** Indicates if the language is optional. */
    readonly isOptional!: boolean;

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IAppLanguageDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).iso2Code = _data["iso2Code"];
        (<any>this).englishName = _data["englishName"];
        if (Array.isArray(_data["fallback"])) {
            (<any>this).fallback = [] as any;
            for (let item of _data["fallback"])
                (<any>this).fallback!.push(item);
        }
        (<any>this).isMaster = _data["isMaster"];
        (<any>this).isOptional = _data["isOptional"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AppLanguageDto {
        const result = new AppLanguageDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["iso2Code"] = this.iso2Code;
        data["englishName"] = this.englishName;
        if (Array.isArray(this.fallback)) {
            data["fallback"] = [];
            for (let item of this.fallback)
                data["fallback"].push(item);
        }
        data["isMaster"] = this.isMaster;
        data["isOptional"] = this.isOptional;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAppLanguageDto extends IResourceDto {
    /** The iso code of the language. */
    readonly iso2Code: string;
    /** The english name of the language. */
    readonly englishName: string;
    /** The fallback languages. */
    readonly fallback: string[];
    /** Indicates if the language is the master language. */
    readonly isMaster: boolean;
    /** Indicates if the language is optional. */
    readonly isOptional: boolean;
}

export class AddLanguageDto implements IAddLanguageDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The language to add. */
    readonly language!: string;

    constructor(data?: IAddLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).language = _data["language"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AddLanguageDto {
        const result = new AddLanguageDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["language"] = this.language;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAddLanguageDto {
    /** The language to add. */
    readonly language: string;
}

export class UpdateLanguageDto implements IUpdateLanguageDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Set the value to true to make the language the master. */
    readonly isMaster?: boolean | undefined;
    /** Set the value to true to make the language optional. */
    readonly isOptional?: boolean;
    /** Optional fallback languages. */
    readonly fallback?: string[] | undefined;

    constructor(data?: IUpdateLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).isMaster = _data["isMaster"];
        (<any>this).isOptional = _data["isOptional"];
        if (Array.isArray(_data["fallback"])) {
            (<any>this).fallback = [] as any;
            for (let item of _data["fallback"])
                (<any>this).fallback!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateLanguageDto {
        const result = new UpdateLanguageDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["isMaster"] = this.isMaster;
        data["isOptional"] = this.isOptional;
        if (Array.isArray(this.fallback)) {
            data["fallback"] = [];
            for (let item of this.fallback)
                data["fallback"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateLanguageDto {
    /** Set the value to true to make the language the master. */
    readonly isMaster?: boolean | undefined;
    /** Set the value to true to make the language optional. */
    readonly isOptional?: boolean;
    /** Optional fallback languages. */
    readonly fallback?: string[] | undefined;
}

export class RolesDto extends ResourceDto implements IRolesDto {
    /** The roles. */
    readonly items!: RoleDto[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    constructor(data?: IRolesDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(RoleDto.fromJSON(item));
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RolesDto {
        const result = new RolesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IRolesDto extends IResourceDto {
    /** The roles. */
    readonly items: RoleDto[];
}

export class RoleDto extends ResourceDto implements IRoleDto {
    /** The role name. */
    readonly name!: string;
    /** The number of clients with this role. */
    readonly numClients!: number;
    /** The number of contributors with this role. */
    readonly numContributors!: number;
    /** Indicates if the role is an builtin default role. */
    readonly isDefaultRole!: boolean;
    /** Associated list of permissions. */
    readonly permissions!: string[];
    /** Associated list of UI properties. */
    readonly properties!: { [key: string]: any; };

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'update'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IRoleDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).name = _data["name"];
        (<any>this).numClients = _data["numClients"];
        (<any>this).numContributors = _data["numContributors"];
        (<any>this).isDefaultRole = _data["isDefaultRole"];
        if (Array.isArray(_data["permissions"])) {
            (<any>this).permissions = [] as any;
            for (let item of _data["permissions"])
                (<any>this).permissions!.push(item);
        }
        if (_data["properties"]) {
            (<any>this).properties = {} as any;
            for (let key in _data["properties"]) {
                if (_data["properties"].hasOwnProperty(key))
                    (<any>(<any>this).properties)![key] = _data["properties"][key];
            }
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): RoleDto {
        const result = new RoleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["numClients"] = this.numClients;
        data["numContributors"] = this.numContributors;
        data["isDefaultRole"] = this.isDefaultRole;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IRoleDto extends IResourceDto {
    /** The role name. */
    readonly name: string;
    /** The number of clients with this role. */
    readonly numClients: number;
    /** The number of contributors with this role. */
    readonly numContributors: number;
    /** Indicates if the role is an builtin default role. */
    readonly isDefaultRole: boolean;
    /** Associated list of permissions. */
    readonly permissions: string[];
    /** Associated list of UI properties. */
    readonly properties: { [key: string]: any; };
}

export class AddRoleDto implements IAddRoleDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The role name. */
    readonly name!: string;

    constructor(data?: IAddRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AddRoleDto {
        const result = new AddRoleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAddRoleDto {
    /** The role name. */
    readonly name: string;
}

export class UpdateRoleDto implements IUpdateRoleDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Associated list of permissions. */
    readonly permissions!: string[];
    /** Associated list of UI properties. */
    readonly properties?: { [key: string]: any; };

    constructor(data?: IUpdateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["permissions"])) {
            (<any>this).permissions = [] as any;
            for (let item of _data["permissions"])
                (<any>this).permissions!.push(item);
        }
        if (_data["properties"]) {
            (<any>this).properties = {} as any;
            for (let key in _data["properties"]) {
                if (_data["properties"].hasOwnProperty(key))
                    (<any>(<any>this).properties)![key] = _data["properties"][key];
            }
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateRoleDto {
        const result = new UpdateRoleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateRoleDto {
    /** Associated list of permissions. */
    readonly permissions: string[];
    /** Associated list of UI properties. */
    readonly properties?: { [key: string]: any; };
}

export class AppDto extends ResourceDto implements IAppDto {
    /** The user that has created the app. */
    readonly createdBy?: string | undefined;
    /** The user that has updated the app. */
    readonly lastModifiedBy?: string | undefined;
    /** The ID of the app. */
    readonly id!: string;
    /** The name of the app. */
    readonly name!: string;
    /** The optional label of the app. */
    readonly label?: string | undefined;
    /** The optional description of the app. */
    readonly description?: string | undefined;
    /** The version of the app. */
    readonly version!: number;
    /** The timestamp when the app has been created. */
    readonly created!: DateTime;
    /** The timestamp when the app has been modified last. */
    readonly lastModified!: DateTime;
    /** The ID of the team. */
    readonly teamId?: string | undefined;
    /** The permission level of the user. */
    readonly permissions!: string[];
    /** Indicates if the user can access the api. */
    readonly canAccessApi!: boolean;
    /** Indicates if the user can access at least one content. */
    readonly canAccessContent!: boolean;
    /** The role name of the user. */
    readonly roleName?: string | undefined;
    /** The properties from the role. */
    readonly roleProperties!: { [key: string]: any; };

    get displayName() {
        return this.compute('displayName', () => StringHelper.firstNonEmpty(this.label, this.name));
    }

    get canCreateSchema() {
        return this.compute('canCreateSchema', () => hasAnyLink(this._links, 'schemas/create'));
    }

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canLeave() {
        return this.compute('canLeave', () => hasAnyLink(this._links, 'leave'));
    }

    get canReadAssets() {
        return this.compute('canReadAssets', () => hasAnyLink(this._links, 'assets'));
    }

    get canReadAssetsScripts() {
        return this.compute('canReadAssetsScripts', () => hasAnyLink(this._links, 'assets/scripts'));
    }

    get canReadClients() {
        return this.compute('canReadClients', () => hasAnyLink(this._links, 'clients'));
    }

    get canReadContributors() {
        return this.compute('canReadContributors', () => hasAnyLink(this._links, 'contributors'));
    }

    get canReadJobs() {
        return this.compute('canReadJobs', () => hasAnyLink(this._links, 'jobs'));
    }

    get canReadLanguages() {
        return this.compute('canReadLanguages', () => hasAnyLink(this._links, 'languages'));
    }

    get canReadPatterns() {
        return this.compute('canReadPatterns', () => hasAnyLink(this._links, 'patterns'));
    }

    get canReadPlans() {
        return this.compute('canReadPlans', () => hasAnyLink(this._links, 'plans'));
    }

    get canReadRoles() {
        return this.compute('canReadRoles', () => hasAnyLink(this._links, 'roles'));
    }

    get canReadRules() {
        return this.compute('canReadRules', () => hasAnyLink(this._links, 'rules'));
    }

    get canReadSchemas() {
        return this.compute('canReadSchemas', () => hasAnyLink(this._links, 'schemas'));
    }

    get canReadWorkflows() {
        return this.compute('canReadWorkflows', () => hasAnyLink(this._links, 'workflows'));
    }

    get canUpdateGeneral() {
        return this.compute('canUpdateGeneral', () => hasAnyLink(this._links, 'update'));
    }

    get canUpdateImage() {
        return this.compute('canUpdateImage', () => hasAnyLink(this._links, 'image/upload'));
    }

    get canUpdateTeam() {
        return this.compute('canUpdateTeam', () => hasAnyLink(this._links, 'transfer'));
    }

    get canUploadAssets() {
        return this.compute('canUploadAssets', () => hasAnyLink(this._links, 'assets/create'));
    }

    get image() {
        return this.compute('image', () => this._links['image']?.href);
    }

    constructor(data?: IAppDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).createdBy = _data["createdBy"];
        (<any>this).lastModifiedBy = _data["lastModifiedBy"];
        (<any>this).id = _data["id"];
        (<any>this).name = _data["name"];
        (<any>this).label = _data["label"];
        (<any>this).description = _data["description"];
        (<any>this).version = _data["version"];
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).lastModified = _data["lastModified"] ? DateTime.parseISO(_data["lastModified"].toString()) : <any>undefined;
        (<any>this).teamId = _data["teamId"];
        if (Array.isArray(_data["permissions"])) {
            (<any>this).permissions = [] as any;
            for (let item of _data["permissions"])
                (<any>this).permissions!.push(item);
        }
        (<any>this).canAccessApi = _data["canAccessApi"];
        (<any>this).canAccessContent = _data["canAccessContent"];
        (<any>this).roleName = _data["roleName"];
        if (_data["roleProperties"]) {
            (<any>this).roleProperties = {} as any;
            for (let key in _data["roleProperties"]) {
                if (_data["roleProperties"].hasOwnProperty(key))
                    (<any>(<any>this).roleProperties)![key] = _data["roleProperties"][key];
            }
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AppDto {
        const result = new AppDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        data["description"] = this.description;
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["teamId"] = this.teamId;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["canAccessApi"] = this.canAccessApi;
        data["canAccessContent"] = this.canAccessContent;
        data["roleName"] = this.roleName;
        if (this.roleProperties) {
            data["roleProperties"] = {};
            for (let key in this.roleProperties) {
                if (this.roleProperties.hasOwnProperty(key))
                    (<any>data["roleProperties"])[key] = (<any>this.roleProperties)[key];
            }
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAppDto extends IResourceDto {
    /** The user that has created the app. */
    readonly createdBy?: string | undefined;
    /** The user that has updated the app. */
    readonly lastModifiedBy?: string | undefined;
    /** The ID of the app. */
    readonly id: string;
    /** The name of the app. */
    readonly name: string;
    /** The optional label of the app. */
    readonly label?: string | undefined;
    /** The optional description of the app. */
    readonly description?: string | undefined;
    /** The version of the app. */
    readonly version: number;
    /** The timestamp when the app has been created. */
    readonly created: DateTime;
    /** The timestamp when the app has been modified last. */
    readonly lastModified: DateTime;
    /** The ID of the team. */
    readonly teamId?: string | undefined;
    /** The permission level of the user. */
    readonly permissions: string[];
    /** Indicates if the user can access the api. */
    readonly canAccessApi: boolean;
    /** Indicates if the user can access at least one content. */
    readonly canAccessContent: boolean;
    /** The role name of the user. */
    readonly roleName?: string | undefined;
    /** The properties from the role. */
    readonly roleProperties: { [key: string]: any; };
}

export class CreateAppDto implements ICreateAppDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the app. */
    readonly name!: string;
    /** Initialize the app with the inbuilt template. */
    readonly template?: string | undefined;

    constructor(data?: ICreateAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).template = _data["template"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): CreateAppDto {
        const result = new CreateAppDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["template"] = this.template;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ICreateAppDto {
    /** The name of the app. */
    readonly name: string;
    /** Initialize the app with the inbuilt template. */
    readonly template?: string | undefined;
}

export class UpdateAppDto implements IUpdateAppDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The optional label of your app. */
    readonly label?: string | undefined;
    /** The optional description of your app. */
    readonly description?: string | undefined;

    constructor(data?: IUpdateAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).label = _data["label"];
        (<any>this).description = _data["description"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateAppDto {
        const result = new UpdateAppDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["label"] = this.label;
        data["description"] = this.description;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateAppDto {
    /** The optional label of your app. */
    readonly label?: string | undefined;
    /** The optional description of your app. */
    readonly description?: string | undefined;
}

export class TransferToTeamDto implements ITransferToTeamDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The ID of the team. */
    readonly teamId?: string | undefined;

    constructor(data?: ITransferToTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).teamId = _data["teamId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): TransferToTeamDto {
        const result = new TransferToTeamDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["teamId"] = this.teamId;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface ITransferToTeamDto {
    /** The ID of the team. */
    readonly teamId?: string | undefined;
}

export class AppSettingsDto extends ResourceDto implements IAppSettingsDto {
    /** The configured app patterns. */
    readonly patterns!: PatternDto[];
    /** The configured UI editors. */
    readonly editors!: EditorDto[];
    /** Hide the scheduler for content items. */
    readonly hideScheduler!: boolean;
    /** Hide the datetime mode button. */
    readonly hideDateTimeModeButton!: boolean;
    /** The version of the app. */
    readonly version!: number;

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IAppSettingsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["patterns"])) {
            (<any>this).patterns = [] as any;
            for (let item of _data["patterns"])
                (<any>this).patterns!.push(PatternDto.fromJSON(item));
        }
        if (Array.isArray(_data["editors"])) {
            (<any>this).editors = [] as any;
            for (let item of _data["editors"])
                (<any>this).editors!.push(EditorDto.fromJSON(item));
        }
        (<any>this).hideScheduler = _data["hideScheduler"];
        (<any>this).hideDateTimeModeButton = _data["hideDateTimeModeButton"];
        (<any>this).version = _data["version"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AppSettingsDto {
        const result = new AppSettingsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.patterns)) {
            data["patterns"] = [];
            for (let item of this.patterns)
                data["patterns"].push(item.toJSON());
        }
        if (Array.isArray(this.editors)) {
            data["editors"] = [];
            for (let item of this.editors)
                data["editors"].push(item.toJSON());
        }
        data["hideScheduler"] = this.hideScheduler;
        data["hideDateTimeModeButton"] = this.hideDateTimeModeButton;
        data["version"] = this.version;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IAppSettingsDto extends IResourceDto {
    /** The configured app patterns. */
    readonly patterns: PatternDto[];
    /** The configured UI editors. */
    readonly editors: EditorDto[];
    /** Hide the scheduler for content items. */
    readonly hideScheduler: boolean;
    /** Hide the datetime mode button. */
    readonly hideDateTimeModeButton: boolean;
    /** The version of the app. */
    readonly version: number;
}

export class PatternDto implements IPatternDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the suggestion. */
    readonly name!: string;
    /** The regex pattern. */
    readonly regex!: string;
    /** The regex message. */
    readonly message?: string | undefined;

    constructor(data?: IPatternDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).regex = _data["regex"];
        (<any>this).message = _data["message"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): PatternDto {
        const result = new PatternDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["regex"] = this.regex;
        data["message"] = this.message;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IPatternDto {
    /** The name of the suggestion. */
    readonly name: string;
    /** The regex pattern. */
    readonly regex: string;
    /** The regex message. */
    readonly message?: string | undefined;
}

export class EditorDto implements IEditorDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the editor. */
    readonly name!: string;
    /** The url to the editor. */
    readonly url!: string;

    constructor(data?: IEditorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).url = _data["url"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): EditorDto {
        const result = new EditorDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["url"] = this.url;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IEditorDto {
    /** The name of the editor. */
    readonly name: string;
    /** The url to the editor. */
    readonly url: string;
}

export class UpdateAppSettingsDto implements IUpdateAppSettingsDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The configured app patterns. */
    readonly patterns!: PatternDto[];
    /** The configured UI editors. */
    readonly editors!: EditorDto[];
    /** Hide the scheduler for content items. */
    readonly hideScheduler?: boolean;
    /** Hide the datetime mode button. */
    readonly hideDateTimeModeButton?: boolean;

    constructor(data?: IUpdateAppSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (Array.isArray(_data["patterns"])) {
            (<any>this).patterns = [] as any;
            for (let item of _data["patterns"])
                (<any>this).patterns!.push(PatternDto.fromJSON(item));
        }
        if (Array.isArray(_data["editors"])) {
            (<any>this).editors = [] as any;
            for (let item of _data["editors"])
                (<any>this).editors!.push(EditorDto.fromJSON(item));
        }
        (<any>this).hideScheduler = _data["hideScheduler"];
        (<any>this).hideDateTimeModeButton = _data["hideDateTimeModeButton"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateAppSettingsDto {
        const result = new UpdateAppSettingsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.patterns)) {
            data["patterns"] = [];
            for (let item of this.patterns)
                data["patterns"].push(item.toJSON());
        }
        if (Array.isArray(this.editors)) {
            data["editors"] = [];
            for (let item of this.editors)
                data["editors"].push(item.toJSON());
        }
        data["hideScheduler"] = this.hideScheduler;
        data["hideDateTimeModeButton"] = this.hideDateTimeModeButton;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateAppSettingsDto {
    /** The configured app patterns. */
    readonly patterns: PatternDto[];
    /** The configured UI editors. */
    readonly editors: EditorDto[];
    /** Hide the scheduler for content items. */
    readonly hideScheduler?: boolean;
    /** Hide the datetime mode button. */
    readonly hideDateTimeModeButton?: boolean;
}

export class WorkflowsDto extends ResourceDto implements IWorkflowsDto {
    /** The workflow. */
    readonly items!: WorkflowDto[];
    /** The errros that should be fixed. */
    readonly errors!: string[];

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    constructor(data?: IWorkflowsDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(WorkflowDto.fromJSON(item));
        }
        if (Array.isArray(_data["errors"])) {
            (<any>this).errors = [] as any;
            for (let item of _data["errors"])
                (<any>this).errors!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): WorkflowsDto {
        const result = new WorkflowsDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IWorkflowsDto extends IResourceDto {
    /** The workflow. */
    readonly items: WorkflowDto[];
    /** The errros that should be fixed. */
    readonly errors: string[];
}

export class WorkflowDto extends ResourceDto implements IWorkflowDto {
    /** The workflow id. */
    readonly id!: string;
    /** The name of the workflow. */
    readonly name?: string | undefined;
    /** The workflow steps. */
    readonly steps!: { [key: string]: WorkflowStepDto; };
    /** The schema ids. */
    readonly schemaIds?: string[] | undefined;
    /** The initial step. */
    readonly initial!: string;

    get displayName() {
        return this.compute('displayName', () => StringHelper.firstNonEmpty(this.name, 'i18n:workflows.notNamed'));
    }

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IWorkflowDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).name = _data["name"];
        if (_data["steps"]) {
            (<any>this).steps = {} as any;
            for (let key in _data["steps"]) {
                if (_data["steps"].hasOwnProperty(key))
                    (<any>(<any>this).steps)![key] = _data["steps"][key] ? WorkflowStepDto.fromJSON(_data["steps"][key]) : new WorkflowStepDto();
            }
        }
        if (Array.isArray(_data["schemaIds"])) {
            (<any>this).schemaIds = [] as any;
            for (let item of _data["schemaIds"])
                (<any>this).schemaIds!.push(item);
        }
        (<any>this).initial = _data["initial"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): WorkflowDto {
        const result = new WorkflowDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.steps) {
            data["steps"] = {};
            for (let key in this.steps) {
                if (this.steps.hasOwnProperty(key))
                    (<any>data["steps"])[key] = this.steps[key] ? this.steps[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["initial"] = this.initial;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IWorkflowDto extends IResourceDto {
    /** The workflow id. */
    readonly id: string;
    /** The name of the workflow. */
    readonly name?: string | undefined;
    /** The workflow steps. */
    readonly steps: { [key: string]: WorkflowStepDto; };
    /** The schema ids. */
    readonly schemaIds?: string[] | undefined;
    /** The initial step. */
    readonly initial: string;
}

export class WorkflowStepDto implements IWorkflowStepDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The transitions. */
    readonly transitions?: { [key: string]: WorkflowTransitionDto; };
    /** The optional color. */
    readonly color?: string | undefined;
    /** True if the content should be validated when moving to this step. */
    readonly validate?: boolean;
    /** Indicates if updates should not be allowed. */
    readonly noUpdate?: boolean;
    /** Optional expression that must evaluate to true when you want to prevent updates. */
    readonly noUpdateExpression?: string | undefined;
    /** Optional list of roles to restrict the updates for users with these roles. */
    readonly noUpdateRoles?: string[] | undefined;

    constructor(data?: IWorkflowStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (_data["transitions"]) {
            (<any>this).transitions = {} as any;
            for (let key in _data["transitions"]) {
                if (_data["transitions"].hasOwnProperty(key))
                    (<any>(<any>this).transitions)![key] = _data["transitions"][key] ? WorkflowTransitionDto.fromJSON(_data["transitions"][key]) : new WorkflowTransitionDto();
            }
        }
        (<any>this).color = _data["color"];
        (<any>this).validate = _data["validate"];
        (<any>this).noUpdate = _data["noUpdate"];
        (<any>this).noUpdateExpression = _data["noUpdateExpression"];
        if (Array.isArray(_data["noUpdateRoles"])) {
            (<any>this).noUpdateRoles = [] as any;
            for (let item of _data["noUpdateRoles"])
                (<any>this).noUpdateRoles!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): WorkflowStepDto {
        const result = new WorkflowStepDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this.transitions) {
            data["transitions"] = {};
            for (let key in this.transitions) {
                if (this.transitions.hasOwnProperty(key))
                    (<any>data["transitions"])[key] = this.transitions[key] ? this.transitions[key].toJSON() : <any>undefined;
            }
        }
        data["color"] = this.color;
        data["validate"] = this.validate;
        data["noUpdate"] = this.noUpdate;
        data["noUpdateExpression"] = this.noUpdateExpression;
        if (Array.isArray(this.noUpdateRoles)) {
            data["noUpdateRoles"] = [];
            for (let item of this.noUpdateRoles)
                data["noUpdateRoles"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IWorkflowStepDto {
    /** The transitions. */
    readonly transitions?: { [key: string]: WorkflowTransitionDto; };
    /** The optional color. */
    readonly color?: string | undefined;
    /** True if the content should be validated when moving to this step. */
    readonly validate?: boolean;
    /** Indicates if updates should not be allowed. */
    readonly noUpdate?: boolean;
    /** Optional expression that must evaluate to true when you want to prevent updates. */
    readonly noUpdateExpression?: string | undefined;
    /** Optional list of roles to restrict the updates for users with these roles. */
    readonly noUpdateRoles?: string[] | undefined;
}

export class WorkflowTransitionDto implements IWorkflowTransitionDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The optional expression. */
    readonly expression?: string | undefined;
    /** The optional restricted role. */
    readonly roles?: string[] | undefined;

    constructor(data?: IWorkflowTransitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).expression = _data["expression"];
        if (Array.isArray(_data["roles"])) {
            (<any>this).roles = [] as any;
            for (let item of _data["roles"])
                (<any>this).roles!.push(item);
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): WorkflowTransitionDto {
        const result = new WorkflowTransitionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["expression"] = this.expression;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IWorkflowTransitionDto {
    /** The optional expression. */
    readonly expression?: string | undefined;
    /** The optional restricted role. */
    readonly roles?: string[] | undefined;
}

export class AddWorkflowDto implements IAddWorkflowDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the workflow. */
    readonly name!: string;

    constructor(data?: IAddWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): AddWorkflowDto {
        const result = new AddWorkflowDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IAddWorkflowDto {
    /** The name of the workflow. */
    readonly name: string;
}

export class UpdateWorkflowDto implements IUpdateWorkflowDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The name of the workflow. */
    readonly name?: string | undefined;
    /** The workflow steps. */
    readonly steps!: { [key: string]: WorkflowStepDto; };
    /** The schema ids. */
    readonly schemaIds?: string[] | undefined;
    /** The initial step. */
    readonly initial!: string;

    constructor(data?: IUpdateWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        if (_data["steps"]) {
            (<any>this).steps = {} as any;
            for (let key in _data["steps"]) {
                if (_data["steps"].hasOwnProperty(key))
                    (<any>(<any>this).steps)![key] = _data["steps"][key] ? WorkflowStepDto.fromJSON(_data["steps"][key]) : new WorkflowStepDto();
            }
        }
        if (Array.isArray(_data["schemaIds"])) {
            (<any>this).schemaIds = [] as any;
            for (let item of _data["schemaIds"])
                (<any>this).schemaIds!.push(item);
        }
        (<any>this).initial = _data["initial"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): UpdateWorkflowDto {
        const result = new UpdateWorkflowDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        if (this.steps) {
            data["steps"] = {};
            for (let key in this.steps) {
                if (this.steps.hasOwnProperty(key))
                    (<any>data["steps"])[key] = this.steps[key] ? this.steps[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["initial"] = this.initial;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IUpdateWorkflowDto {
    /** The name of the workflow. */
    readonly name?: string | undefined;
    /** The workflow steps. */
    readonly steps: { [key: string]: WorkflowStepDto; };
    /** The schema ids. */
    readonly schemaIds?: string[] | undefined;
    /** The initial step. */
    readonly initial: string;
}

export class DynamicCreateRuleDto implements IDynamicCreateRuleDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger!: RuleTriggerDto;
    /** The action properties. */
    readonly action?: { [key: string]: any; } | undefined;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow!: DynamicFlowDefinitionDto;
    /** Enable or disable the rule. */
    readonly isEnabled?: boolean | undefined;

    constructor(data?: IDynamicCreateRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).trigger = _data["trigger"] ? RuleTriggerDto.fromJSON(_data["trigger"]) : <any>undefined;
        if (_data["action"]) {
            (<any>this).action = {} as any;
            for (let key in _data["action"]) {
                if (_data["action"].hasOwnProperty(key))
                    (<any>(<any>this).action)![key] = _data["action"][key];
            }
        }
        (<any>this).flow = _data["flow"] ? DynamicFlowDefinitionDto.fromJSON(_data["flow"]) : new DynamicFlowDefinitionDto();
        (<any>this).isEnabled = _data["isEnabled"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DynamicCreateRuleDto {
        const result = new DynamicCreateRuleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["trigger"] = this.trigger ? this.trigger.toJSON() : <any>undefined;
        if (this.action) {
            data["action"] = {};
            for (let key in this.action) {
                if (this.action.hasOwnProperty(key))
                    (<any>data["action"])[key] = (<any>this.action)[key];
            }
        }
        data["flow"] = this.flow ? this.flow.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IDynamicCreateRuleDto {
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger: RuleTriggerDto;
    /** The action properties. */
    readonly action?: { [key: string]: any; } | undefined;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow: DynamicFlowDefinitionDto;
    /** Enable or disable the rule. */
    readonly isEnabled?: boolean | undefined;
}

export class DynamicFlowDefinitionDto implements IDynamicFlowDefinitionDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The ID of the initial step. */
    readonly initialStepId!: string;
    /** The steps. */
    readonly steps!: { [key: string]: DynamicFlowStepDefinitionDto; };

    constructor(data?: IDynamicFlowDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).initialStepId = _data["initialStepId"];
        if (_data["steps"]) {
            (<any>this).steps = {} as any;
            for (let key in _data["steps"]) {
                if (_data["steps"].hasOwnProperty(key))
                    (<any>(<any>this).steps)![key] = _data["steps"][key] ? DynamicFlowStepDefinitionDto.fromJSON(_data["steps"][key]) : new DynamicFlowStepDefinitionDto();
            }
        }
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DynamicFlowDefinitionDto {
        const result = new DynamicFlowDefinitionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["initialStepId"] = this.initialStepId;
        if (this.steps) {
            data["steps"] = {};
            for (let key in this.steps) {
                if (this.steps.hasOwnProperty(key))
                    (<any>data["steps"])[key] = this.steps[key] ? this.steps[key].toJSON() : <any>undefined;
            }
        }
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IDynamicFlowDefinitionDto {
    /** The ID of the initial step. */
    readonly initialStepId: string;
    /** The steps. */
    readonly steps: { [key: string]: DynamicFlowStepDefinitionDto; };
}

export class DynamicFlowStepDefinitionDto implements IDynamicFlowStepDefinitionDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The actual step. */
    readonly step!: { [key: string]: any; };
    /** The optional descriptive name. */
    readonly name?: string | undefined;
    /** The next step. */
    readonly nextStepId?: string | undefined;
    /** Indicates if errors should be ignored. */
    readonly ignoreError?: boolean;

    constructor(data?: IDynamicFlowStepDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        if (_data["step"]) {
            (<any>this).step = {} as any;
            for (let key in _data["step"]) {
                if (_data["step"].hasOwnProperty(key))
                    (<any>(<any>this).step)![key] = _data["step"][key];
            }
        }
        (<any>this).name = _data["name"];
        (<any>this).nextStepId = _data["nextStepId"];
        (<any>this).ignoreError = _data["ignoreError"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DynamicFlowStepDefinitionDto {
        const result = new DynamicFlowStepDefinitionDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (this.step) {
            data["step"] = {};
            for (let key in this.step) {
                if (this.step.hasOwnProperty(key))
                    (<any>data["step"])[key] = (<any>this.step)[key];
            }
        }
        data["name"] = this.name;
        data["nextStepId"] = this.nextStepId;
        data["ignoreError"] = this.ignoreError;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IDynamicFlowStepDefinitionDto {
    /** The actual step. */
    readonly step: { [key: string]: any; };
    /** The optional descriptive name. */
    readonly name?: string | undefined;
    /** The next step. */
    readonly nextStepId?: string | undefined;
    /** Indicates if errors should be ignored. */
    readonly ignoreError?: boolean;
}

export class DynamicFlowExecutionStateDto implements IDynamicFlowExecutionStateDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** The actual definition of the the steps to be executed. */
    readonly definition!: DynamicFlowDefinitionDto;
    /** The context. */
    readonly context!: any;
    /** The state of each step. */
    readonly steps!: { [key: string]: FlowExecutionStepStateDto; };
    /** The next step to be executed. */
    readonly nextStepId!: string;
    /** THe time when the next step will be executed. */
    readonly nextRun?: DateTime | undefined;
    /** The creation time. */
    readonly created!: DateTime;
    /** The completion time. */
    readonly completed!: DateTime;
    /** The overall status. */
    readonly status!: FlowExecutionStatus;

    constructor(data?: IDynamicFlowExecutionStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).definition = _data["definition"] ? DynamicFlowDefinitionDto.fromJSON(_data["definition"]) : new DynamicFlowDefinitionDto();
        (<any>this).context = _data["context"];
        if (_data["steps"]) {
            (<any>this).steps = {} as any;
            for (let key in _data["steps"]) {
                if (_data["steps"].hasOwnProperty(key))
                    (<any>(<any>this).steps)![key] = _data["steps"][key] ? FlowExecutionStepStateDto.fromJSON(_data["steps"][key]) : new FlowExecutionStepStateDto();
            }
        }
        (<any>this).nextStepId = _data["nextStepId"];
        (<any>this).nextRun = _data["nextRun"] ? DateTime.parseISO(_data["nextRun"].toString()) : <any>undefined;
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).completed = _data["completed"] ? DateTime.parseISO(_data["completed"].toString()) : <any>undefined;
        (<any>this).status = _data["status"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DynamicFlowExecutionStateDto {
        const result = new DynamicFlowExecutionStateDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["definition"] = this.definition ? this.definition.toJSON() : <any>undefined;
        data["context"] = this.context;
        if (this.steps) {
            data["steps"] = {};
            for (let key in this.steps) {
                if (this.steps.hasOwnProperty(key))
                    (<any>data["steps"])[key] = this.steps[key] ? this.steps[key].toJSON() : <any>undefined;
            }
        }
        data["nextStepId"] = this.nextStepId;
        data["nextRun"] = this.nextRun ? this.nextRun.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["status"] = this.status;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IDynamicFlowExecutionStateDto {
    /** The actual definition of the the steps to be executed. */
    readonly definition: DynamicFlowDefinitionDto;
    /** The context. */
    readonly context: any;
    /** The state of each step. */
    readonly steps: { [key: string]: FlowExecutionStepStateDto; };
    /** The next step to be executed. */
    readonly nextStepId: string;
    /** THe time when the next step will be executed. */
    readonly nextRun?: DateTime | undefined;
    /** The creation time. */
    readonly created: DateTime;
    /** The completion time. */
    readonly completed: DateTime;
    /** The overall status. */
    readonly status: FlowExecutionStatus;
}

export class DynamicRulesDto extends ResourceDto implements IDynamicRulesDto {
    /** The rules. */
    readonly items!: DynamicRuleDto[];
    /** The ID of the rule that is currently rerunning. */
    readonly runningRuleId?: string | undefined;

    get canCreate() {
        return this.compute('canCreate', () => hasAnyLink(this._links, 'create'));
    }

    get canReadEvents() {
        return this.compute('canReadEvents', () => hasAnyLink(this._links, 'events'));
    }

    get canCancelRun() {
        return this.compute('canCancelRun', () => hasAnyLink(this._links, 'run/cancel'));
    }

    constructor(data?: IDynamicRulesDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        if (Array.isArray(_data["items"])) {
            (<any>this).items = [] as any;
            for (let item of _data["items"])
                (<any>this).items!.push(DynamicRuleDto.fromJSON(item));
        }
        (<any>this).runningRuleId = _data["runningRuleId"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DynamicRulesDto {
        const result = new DynamicRulesDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["runningRuleId"] = this.runningRuleId;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IDynamicRulesDto extends IResourceDto {
    /** The rules. */
    readonly items: DynamicRuleDto[];
    /** The ID of the rule that is currently rerunning. */
    readonly runningRuleId?: string | undefined;
}

export class DynamicRuleDto extends ResourceDto implements IDynamicRuleDto {
    /** The ID of the rule. */
    readonly id!: string;
    /** The user that has created the rule. */
    readonly createdBy!: string;
    /** The user that has updated the rule. */
    readonly lastModifiedBy!: string;
    /** The date and time when the rule has been created. */
    readonly created!: DateTime;
    /** The date and time when the rule has been modified last. */
    readonly lastModified!: DateTime;
    /** The version of the rule. */
    readonly version!: number;
    /** Determines if the rule is enabled. */
    readonly isEnabled!: boolean;
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger!: RuleTriggerDto;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow!: DynamicFlowDefinitionDto;
    /** The action properties. */
    readonly action!: { [key: string]: any; };
    /** The number of completed executions. */
    readonly numSucceeded!: number;
    /** The number of failed executions. */
    readonly numFailed!: number;
    /** The date and time when the rule was executed the last time. */
    readonly lastExecuted?: DateTime | undefined;

    get canDelete() {
        return this.compute('canDelete', () => hasAnyLink(this._links, 'delete'));
    }

    get canDisable() {
        return this.compute('canDisable', () => hasAnyLink(this._links, 'disable'));
    }

    get canEnable() {
        return this.compute('canEnable', () => hasAnyLink(this._links, 'enable'));
    }

    get canReadLogs() {
        return this.compute('canReadLogs', () => hasAnyLink(this._links, 'logs'));
    }

    get canRun() {
        return this.compute('canRun', () => hasAnyLink(this._links, 'run'));
    }

    get canRunFromSnapshots() {
        return this.compute('canRunFromSnapshots', () => hasAnyLink(this._links, 'run/snapshots'));
    }

    get canTrigger() {
        return this.compute('canTrigger', () => hasAnyLink(this._links, 'trigger'));
    }

    get canUpdate() {
        return this.compute('canUpdate', () => hasAnyLink(this._links, 'update'));
    }

    constructor(data?: IDynamicRuleDto) {
        super(data);
    }

    init(_data: any) {
        super.init(_data);
        (<any>this).id = _data["id"];
        (<any>this).createdBy = _data["createdBy"];
        (<any>this).lastModifiedBy = _data["lastModifiedBy"];
        (<any>this).created = _data["created"] ? DateTime.parseISO(_data["created"].toString()) : <any>undefined;
        (<any>this).lastModified = _data["lastModified"] ? DateTime.parseISO(_data["lastModified"].toString()) : <any>undefined;
        (<any>this).version = _data["version"];
        (<any>this).isEnabled = _data["isEnabled"];
        (<any>this).name = _data["name"];
        (<any>this).trigger = _data["trigger"] ? RuleTriggerDto.fromJSON(_data["trigger"]) : <any>undefined;
        (<any>this).flow = _data["flow"] ? DynamicFlowDefinitionDto.fromJSON(_data["flow"]) : new DynamicFlowDefinitionDto();
        if (_data["action"]) {
            (<any>this).action = {} as any;
            for (let key in _data["action"]) {
                if (_data["action"].hasOwnProperty(key))
                    (<any>(<any>this).action)![key] = _data["action"][key];
            }
        }
        (<any>this).numSucceeded = _data["numSucceeded"];
        (<any>this).numFailed = _data["numFailed"];
        (<any>this).lastExecuted = _data["lastExecuted"] ? DateTime.parseISO(_data["lastExecuted"].toString()) : <any>undefined;
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DynamicRuleDto {
        const result = new DynamicRuleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["isEnabled"] = this.isEnabled;
        data["name"] = this.name;
        data["trigger"] = this.trigger ? this.trigger.toJSON() : <any>undefined;
        data["flow"] = this.flow ? this.flow.toJSON() : <any>undefined;
        if (this.action) {
            data["action"] = {};
            for (let key in this.action) {
                if (this.action.hasOwnProperty(key))
                    (<any>data["action"])[key] = (<any>this.action)[key];
            }
        }
        data["numSucceeded"] = this.numSucceeded;
        data["numFailed"] = this.numFailed;
        data["lastExecuted"] = this.lastExecuted ? this.lastExecuted.toISOString() : <any>undefined;
        super.toJSON(data);
        this.cleanup(data);
        return data;
    }
}

export interface IDynamicRuleDto extends IResourceDto {
    /** The ID of the rule. */
    readonly id: string;
    /** The user that has created the rule. */
    readonly createdBy: string;
    /** The user that has updated the rule. */
    readonly lastModifiedBy: string;
    /** The date and time when the rule has been created. */
    readonly created: DateTime;
    /** The date and time when the rule has been modified last. */
    readonly lastModified: DateTime;
    /** The version of the rule. */
    readonly version: number;
    /** Determines if the rule is enabled. */
    readonly isEnabled: boolean;
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger: RuleTriggerDto;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow: DynamicFlowDefinitionDto;
    /** The action properties. */
    readonly action: { [key: string]: any; };
    /** The number of completed executions. */
    readonly numSucceeded: number;
    /** The number of failed executions. */
    readonly numFailed: number;
    /** The date and time when the rule was executed the last time. */
    readonly lastExecuted?: DateTime | undefined;
}

export class DynamicUpdateRuleDto implements IDynamicUpdateRuleDto {
    /** Uses the cache values because the actual object is frozen. */
    private readonly cachedValues: { [key: string]: any } = {};
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger?: RuleTriggerDto | undefined;
    /** The action properties. */
    readonly action?: { [key: string]: any; } | undefined;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow?: DynamicFlowDefinitionDto | undefined;
    /** Enable or disable the rule. */
    readonly isEnabled?: boolean | undefined;

    constructor(data?: IDynamicUpdateRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data: any) {
        (<any>this).name = _data["name"];
        (<any>this).trigger = _data["trigger"] ? RuleTriggerDto.fromJSON(_data["trigger"]) : <any>undefined;
        if (_data["action"]) {
            (<any>this).action = {} as any;
            for (let key in _data["action"]) {
                if (_data["action"].hasOwnProperty(key))
                    (<any>(<any>this).action)![key] = _data["action"][key];
            }
        }
        (<any>this).flow = _data["flow"] ? DynamicFlowDefinitionDto.fromJSON(_data["flow"]) : <any>undefined;
        (<any>this).isEnabled = _data["isEnabled"];
        this.cleanup(this);
        return this;
    }

    static fromJSON(data: any): DynamicUpdateRuleDto {
        const result = new DynamicUpdateRuleDto().init(data);
        result.cleanup(this);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {}; 
        data["name"] = this.name;
        data["trigger"] = this.trigger ? this.trigger.toJSON() : <any>undefined;
        if (this.action) {
            data["action"] = {};
            for (let key in this.action) {
                if (this.action.hasOwnProperty(key))
                    (<any>data["action"])[key] = (<any>this.action)[key];
            }
        }
        data["flow"] = this.flow ? this.flow.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        this.cleanup(data);
        return data;
    }

    protected cleanup(target: any) {
        for (var property in target) {
            if (target.hasOwnProperty(property)) {
                const value = target[property];
                if (value === undefined) {
                    delete target[property];
                }
            }
        }
    }

    protected compute<T>(key: string, action: () => T): T {
        if (!this.cachedValues.hasOwnProperty(key)) {
            const value = action();
            this.cachedValues[key] = value;
            return value;
        } else {
            return this.cachedValues[key] as any;
        }
    }
}

export interface IDynamicUpdateRuleDto {
    /** Optional rule name. */
    readonly name?: string | undefined;
    /** The trigger properties. */
    readonly trigger?: RuleTriggerDto | undefined;
    /** The action properties. */
    readonly action?: { [key: string]: any; } | undefined;
    /** The flow to describe the sequence of actions to perform. */
    readonly flow?: DynamicFlowDefinitionDto | undefined;
    /** Enable or disable the rule. */
    readonly isEnabled?: boolean | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

/* eslint-disable sort-imports */
// eslint-disable-next-line @typescript-eslint/no-unused-vars













//
// FIELD TYPES
//